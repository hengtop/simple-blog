{
  "users": [
    {
      "id": 1,
      "name": "高修文"
    },
    {
      "id": 2,
      "name": "熊天成"
    },
    {
      "id": 3,
      "name": "郑华"
    },
    {
      "id": 4,
      "name": "王文静"
    }
  ],
  "articleList": [
    {
      "title": "默认标题1",
      "publishTime": "2022-05-29 16:37:09",
      "context": "# js的blur事件和click事件冲突问题\n\n这是我在做一个评论功能的时候遇到了一个问题。\n\n首先用户点击 评论 按钮可以 显示/隐藏 评论回复框，\n\n![image-20220409142541847](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20220409142541847.png)评论框显示后会自动聚焦引导用户输入，评论框失焦后就会隐藏输入框，这一点和掘金的评论框回复交互有点类似。\n\n点击 发表 按钮触发点击事件提交用户评论内容并发送网络请求。这里我点击的时候却先触发了`blur`事件，导致评论框消失，所以我的点击事件不会触发了，毕竟元素消失了。\n\n所以以下是我的解决方案：\n\n## 方式一\n\n点击的时候考虑鼠标按下会依次触发那些事件。\n\n一般来说我们鼠标点击一次会以此触发以下事件：\n\n`onMouseDown` ==> `onMouseUp`  ==> `onClick`\n\n而当用户在非聚焦的元素上触发`onMouseDown`，此时有聚焦的元素就会默认触发`onBlur`，当然如果你想让一个元素聚焦，那么触发`onMouseDown`，也会默认触发`onFoucs`事件的。\n\n所以我们可以在这个事件的处理函数中使用`e.preventDefault()`。这样就阻止了默认触发`blur`事件。\n\n以下是一个`demo`演示：\n\n```js\n// 测试blur和click冲突\nimport React, { memo, useState } from \"react\";\n\nexport default memo(function index() {\n  //props/state\n  const [isShowInput, setIsShowInput] = useState(false);\n  const onBlurHandle = () => {\n    console.log(\"blur\");\n    setIsShowInput(false);\n  };\n  const onClick = () => {\n    console.log(\"click\");\n  };\n  const onMouseDown = (e) => {\n    e.preventDefault();\n    console.log(\"onMouseDown\");\n  };\n\n  return (\n    <>\n      <br />\n      <button onClick={() => setIsShowInput(!isShowInput)}>显示/隐藏</button>\n      {isShowInput && (\n        <div>\n          <input type=\"text\" onBlur={onBlurHandle} />\n          <button onMouseDown={onMouseDown} onClick={onClick}>\n            点击\n          </button>\n        </div>\n      )}\n    </>\n  );\n});\n```\n\n## 方式二\n\n更暴力的方法就是你直接将点击事件处理函数中的逻辑定义在`onMouseDown`事件处理函数中。\n\n\n\n",
      "type": 1,
      "categoryIds": [11, 1, 2, 12],
      "id": 1
    },
    {
      "title": "121",
      "categoryIds": [11],
      "context": "2\n121\n\n",
      "type": 1,
      "id": 2
    },
    {
      "title": "javascript",
      "categoryIds": [11, 2, 1],
      "context": "## 基础知识\n\n编程语言按照数据类型来区分的话是分为静态类型语言和动态类型语言。而JavaScript是一门典型的动态语言，我们对变量进行赋值的时候不用考虑其类型，所以JavaScript具有很大的灵活性。\n\n### 多态\n\n多态的含义： 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n\n其实在JavaScript中多态很容易实现，下面演示一段‘多态‘的代码：\n\n```js\nclass Duck {\n}\n\nclass Dog {\n}\n\nconst dog = new Dog();\nconst duck = new Duck()\n\n\n\nfunction makeSound(animal) {\n  if (animal instanceof Duck) {\n    console.log('嘎嘎嘎');\n  } else if (animal instanceof Dog) {\n    console.log('wangwangwang');\n  }\n}\n\nmakeSound(duck);\nmakeSound(dog)\n// 嘎嘎嘎\n// wangwangwang\n```\n\n上面的代码确实是体现了多态，传入不同的参数反应出不同的结果，但是其内部实现确实有点问题，当我们又添加了一个动物，我们需要修改makeSound中的代码，如果加了很多动物，那该函数内部的if else也会增加，所以我们可以把不变的保留，变得部分提取出去。\n\n优化后的代码：\n\n```js\nclass Duck {\n  sound() {\n    console.log('gagaga');\n  }\n}\n\nclass Dog {\n  sound() {\n    console.log('wangwangwang')\n  }\n}\n\nconst dog = new Dog();\nconst duck = new Duck()\n\n\n\nfunction makeSound(animal) {\n  animal.sound()\n}\n\nmakeSound(duck);\nmakeSound(dog)\n// gagaga\n// wangwangwang\n```\n\n将各个动物叫的方法封装到自身上，然后makeSound只会调用sound方法，只要有该方法的对象都可以穿入makeSound。这样我们只需要添加一个动物并实现sound方法，并不需要去修改makeSound了。这样就消除了分支语句。\n\n### 函数currying和uncurrying\n\ncurrying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。\n\n当我们需要对一个函数的参数做分步的处理就可以使用该方式。\n\n```js\nconst currying = function (fn) {\n  console.log();\n  const length = fn.length;\n  return function (...args) {\n    console.log(arguments);\n    if (args.length < length) {\n      return currying(fn.bind(this, ...args));\n    } else {\n      return fn.apply(this, args)\n    }\n  }\n}\n\nfunction MyCurrying(fn) {\n  function curried(...args) {\n    // 判断接收参数个数\n    if (args.length >= fn.length) {\n      return fn.apply(this, args)\n    } else {\n      // 没有达到参数个数要求就返回函数继续接收参数，递归调用\n      function curried2(...args2) {\n        return curried.apply(this, [...args, ...args2])\n      }\n      return curried2\n    }\n  }\n  return curried\n}\n\nfunction sum(a, b, c, d) {\n  return `[${a}]-[${b}]:${c}:${d}`\n}\n\nconst currySum = currying(sum);\nconsole.log(currySum(1, 2, 3)(4));\nconsole.log(currySum(1, 2)(3, 4));\nconst waitSum = currySum('feat', 'zhangsan');\nconsole.log(waitSum('添加功能', '添加了'));\nconsole.log(waitSum('修改字段')('修改失败'));\n```\n\n在JavaScript中一个对象也未必只能使用它自身的方法，我们可以通过call/apply来实现这一功能\n\n```js\nfunction foo(...args) {\n  Array.prototype.push.call(args, 4);\n  console.log(args);\n}\n\nfoo(1, 2, 3, 4, 5);\n// [ 1, 2, 3, 4, 5, 4 ]\n```\n\n现在我们吧this泛化的过程提取出来，我们就可以使用uncurrying来实现，下面是其实现的方式之一：\n\n```js\nFunction.prototype.uncurrying = function () {\n  const self = this;\n  return function (...args) {\n    // 截取第一个值并返回第一个参数\n    const obj = Array.prototype.shift.call(args);\n    return self.apply(obj, args);\n  }\n}\n```\n\n接下来我们改造下之前的代码：\n\n```js\nconst push = Array.prototype.push.uncurrying();\n\nfunction foo(...args) {\n  push(args, 4);\n  console.log(args);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 1,2,3,4,5,4\n```\n\n现在我们可以看出，我们将数组push方法改造为了一个通用的方法。每次写就不用写那么长的原型了。uncurrying还有另外一种实现：\n\n```js\nFunction.prototype.uncurrying = function () {\n  const self = this;\n  return function (...args) {\n    // 截取第一个值并返回该元素\n    return  Fn = Function.prototype.call.apply(self, args);\n  }\n}\n```\n\n### 分时函数\n\n在渲染大量的DOM的时候，如果一次性加载的问题，浏览器可能会卡住。这塞我们需要调整渲染方式，让节点在一定的时间加载一定。\n\n注意在浏览器中测试。\n\n```js\n// 生成数组\nconst ary = [];\nfor (let i = 0; i <= 1000; i++) {\n  ary.push(i);\n}\n \n\n// 设置渲染\nconst renderList = function (data) {\n  for (let i = 0, l = data.length; i < l; i++) {\n\n  } \n}\n\n// renderList(ary)\n\n\nfunction timeChunk(data, fn, count) {\n  let obj, t;\n  const len = data.length;\n  // 一次性需创建的个数\n  const start = function () {\n    for (let i = 0; i < Math.min(count || 1, data.length); i++) {\n      const obj = data.shift();\n      fn(obj);\n    }\n  }\n  return function () {\n    t = setInterval(() => {\n      if (data.length === 0) {\n        return clearInterval(t)\n      }\n      start();\n    }, 200)\n  }\n}\n\nconst optRenderList = timeChunk(ary, (obj) => {\n  const div = document.createElement('div');\n  div.innerHTML = obj;\n  div.className = 'box'\n  document.body.appendChild(div);\n}, 10)\n\noptRenderList();\n```\n\n### 惰性加载函数\n\n在浏览器中我们可能要对一些方法做一些兼容性的处理。\n\n```js\nlet addEvent = function (ele, type, handler) {\n  if (window.addEventListener) {\n    addEvent = function (ele, type, handler) {\n      ele.addEventListener(type, handler, false)\n    }\n  } else if (window.attachEvent) {\n    addEvent = function (ele, type, handler) {\n      ele.attachEvent('on' + type, handler);\n    }\n  }\n  addEvent(ele, type, handler);\n}\n```\n\n```js\nconst box1 = document.querySelector('.box1');\n      box1.onclick = debounce(function () {\n      console.log('点击了')\n    }, 300)\n    addEvent(box1, 'click', function () {\n      console.log('惰性加载');\n    })\n```\n\n上述做到了使用的时候重写函数，保证性能的优化，而不需要一开始加载代码的时候就去判断兼容性。\n\n## 设计模式\n\n### 原型模式\n\n#### 一些概念\n\n原型模式不单单是一个设计模式，也是一种编程范式。其实现的关键是语言本身是否提供了clone方法。\n\n首先JavaScript就是一门基于原型模式和原型继承的一门语言，其面向对象的系统就是基于原型来构建的。\n\n原型模式在设计模式的角度看是创建对象的一种方式。原型模式通过克隆来创建对象。原型模式实现的关键在于语言本身是否提供clone，例如ES5的Object.create方法。\n\n当然其兼容的实现方法为：\n\n```js\nfunction create(obj) {\n  function Fn(){};\n  Fn.prototype = obj;\n  return new Fn();\n}\n```\n\n另外要注意，原型模式的克隆并不是要得到一个完全一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。\n\n#### 原型继承\n\n在实现原型继承方面，JavaScript遵循以下原型编程的规则：\n\n- 所有的数据都是对象。\n- 得到一个对象并不是通过实例化类，而是使用一个对象作为原型去克隆得到一个新对象。\n- 对象是能访问其原型的。\n- 而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段（原型链）。\n\nJavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象。我们在JavaScript遇到的每个对象，实际上都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。\n\n在JavaScript中虽然我们可以通过new 构造函数的方式来实例化一个对象，但是该语言中并没有类的概念，而且去分析new的过程也会发现实例化的过程也是使用的原型去克隆。就算是ES6新出的class语法使得JavaScript看起来像传统的基于类的语言了，但实际上本质还是基于原型机制创建对象，class仅仅只是一个语法糖而已。\n\n#### 总结\n\n这里以JavaScript语言面对对象的系统设计来简要介绍了原型模式。其实这也证实了一句话：设计模式其实是对一门语言不足的一个补充，如果要使用设计模式不如去寻找更好的一门语言。当然随着编程语言的不断发展，一些设计模式可能天然就内置了，不再需要强行模拟实现。\n\n### 单例模式\n\n定义：保证一个类只有一个实例，并提供一个可访问它的全局访问点。\n\n#### 实现一个单例模式\n\n以下是一个单例模式的基本实现，原理就是第一次创建一个实例，并保存该实例的引用，第二次想创建的时候就直接返回第一次创建的实例引用。\n\n```js\nclass SingleDog {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  getName() {\n    return this.name\n  }\n  static instance = null;\n  static getInstance(name, age) {\n    if (!this.instance) {\n      this.instance = new SingleDog(name, age);\n    }\n    return this.instance;\n  }\n}\n\nconst dog = SingleDog.getInstance('lala', 11);\nconst dog2 = SingleDog.getInstance('qiqi', 11);\nconsole.log(dog, dog2, dog === dog2);\n```\n\n#### 透明的单例模式\n\n之前实现的单例模式虽然功能上没问题，但是在使用上却与我们一般创建对象的方式不一样,用户必须要知道有一个专门创建单例的方法。接下来进行一些改造。\n\n```js\nclass CreateDiv {\n  constructor(html) {\n    if (CreateDiv.instance) {\n      return CreateDiv.instance\n    }\n    this.html = html;\n    this.init();\n    CreateDiv.instance = this;\n    return this;\n  }\n  init() {\n    const div = document.createElement('div');\n    div.innerHTML = this.html;\n    document.body.appendChild(div);\n  }\n}\n\nconst a = new CreateDiv('hello world');\nconst b = new CreateDiv('你好世界');\nconsole.log(a === b);\n```\n\n#### 代理实现单例模式\n\n之前的透明单例使得用法上统一了，但是加入有一天我们想利用该类来创建千万个对象，那我们又必须去修改类内部来支持创建多个对象。这是非常不灵活的。所以我们可以将创建单例的这个行为单独用一个代理类来实现。\n\n```js\nclass CreateDiv {\n  constructor(html) {\n    this.html = html;\n    this.init();\n  }\n  init() {\n    const div = document.createElement('div');\n    div.innerHTML = this.html;\n    document.body.appendChild(div)\n  }\n}\n\nclass ProxySingletonCreateDiv {\n  static instance;\n  constructor(html) {\n    if (!ProxySingletonCreateDiv.instance) {\n      ProxySingletonCreateDiv.instance = new CreateDiv(html)\n    }\n    return ProxySingletonCreateDiv.instance;\n  }\n}\n\nconst a = new ProxySingletonCreateDiv('1');\nconst b = new ProxySingletonCreateDiv('2');\nconsole.log(a === b);\n```\n\n这样我们以后像创建多个对象的时候就直接使用CreateDiv即可，想创建单个对象就使用代理类。\n\n#### JavaScript中的单例模式\n\n上面的介绍其实是通过传统的语言模式来介绍单例模式，但是JavaScript严格意义上并无类这个概念，所以传统的单例模式在JavaScript中并不适用。\n\n我们可以直接通过对象字面量形式创建一个对象：\n\n```js\n// 这个对象是独一无二的\nconst a = {};\n```\n\n#### 惰性单例\n\n惰性单例顾名思义就是使用的时候才去创建。\n\n接下来以一个弹窗案例来体现：\n\n```js\n// 抽离创建单例的逻辑\nconst getSingle = function (fn) {\n  let res;\n  return function (...args) {\n    return res || (res = fn.apply(this, args));\n  }\n}\n\nconst createLoginLayer = function () {\n  const div = document.createElement('div');\n  div.innerHTML = '我是登陆浮窗'\n  div.style.display = 'none'\n  document.body.appendChild(div);\n  return div;\n}\nconst createIframeLayer = function () {\n  const iframe = document.createElement('iframe');\n  document.body.appendChild(iframe);\n  return iframe\n}\n\nconst createSingletonLoginLayer = getSingle(createLoginLayer);\nconst createsingletonIframeLayer = getSingle(createIframeLayer)\ndocument.querySelector('.btn1').onclick = function () {\n  const loginLayer = createSingletonLoginLayer();\n  const iframeLayer = createsingletonIframeLayer();\n  loginLayer.style.display = 'block'\n  iframeLayer.src = 'https://altria.topzhang.cn'\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    div {\n      width: 100px;\n      height: 100px;\n      background-color: #bfa;\n      text-align: center;\n      line-height: 100px;\n      margin: 10px;\n    }\n  </style>\n</head>\n\n<body>\n  <button class=\"btn1\">点击创建</button>\n  <script src=\"./4-惰性单例.js\"></script>\n</body>\n\n</html>\n```\n\n#### 总结\n\n单例模式在JavaScript中也涉及到了闭包和高阶函数的概念，而且单例模式虽然简单，但十分的有用。\n\n### 策略模式\n\n定义：定义一系列的算法，把它们一个一个的封装起来并且使用的时候可随意替换。\n\n#### 奖金计算\n\n员工根据绩效来确定其奖金是多少，比如S绩效四倍工资，A绩效三倍工资等。\n\n```js\n// 奖金根据绩效来计算,每个等级的绩效创建一个类\n\nclass PerformanS {\n  calculate(salary) {\n    return salary * 4\n  }\n}\n\nclass PerformanA {\n  calculate(salary) {\n    return salary * 3\n  }\n}\n\nclass PerformanB {\n  calculate(salary) {\n    return salary * 2\n  }\n}\n\nclass PerformanC {\n  calculate(salary) {\n    return salary * 1\n  }\n}\n\nclass Bonus {\n  // 设置薪水\n  setSalary(salary) {\n    this.salary = salary\n  }\n  // 设置策略对象\n  setStrategy(strategy) {\n    this.strategy = strategy\n  }\n  getBonus() {\n    return this.strategy.calculate(this.salary)\n  }\n}\n\nconst c1 = new Bonus();\nc1.setSalary(10000);\nc1.setStrategy(new PerformanS());\n\nconst c2 = new Bonus();\nc2.setSalary(3000);\nc2.setStrategy(new PerformanC());\n\nconst c3 = new Bonus();\nc3.setSalary(8000);\nc3.setStrategy(new PerformanA());\n\nconst c4 = new Bonus();\nc4.setSalary(6666);\nc4.setStrategy(new PerformanB());\n\nconsole.log(c1.getBonus());\nconsole.log(c2.getBonus());\nconsole.log(c3.getBonus());\nconsole.log(c4.getBonus());\n```\n\n#### JavaScript版奖金计算\n\n上述的奖金计算其实是传统的面向对象基于类的方法实现，但是JavaScript测非常的灵活可直接按照以下方式实现：\n\n```js\n// 之前的计算是基于传统语言的策略模式，js版要更加灵活些\n\nconst strategies = {\n  S(salary) {\n    return salary * 4\n  },\n  A(salary) {\n    return salary * 3\n  },\n  B(salary) {\n    return salary * 2\n  },\n  C(salary) {\n    return salary * 1\n  }\n}\n\nconst calculateBonus = function (level, salary) {\n  return strategies[level](salary);\n}\n\nconsole.log(calculateBonus('S', 2000));\nconsole.log(calculateBonus('A', 1000));\n```\n\n#### 实现小球动画\n\n```js\n// 首先线了解些缓动算法，\n/* \n * t: current time（当前时间）；当前时刻-开始时刻\n * b: beginning value（初始值）；初始位置\n * c: change in value（变化量）；目标位置-变化量\n * d: duration（持续时间）。\n*/\nconst tween = {\n  easeIn: function (t, b, c, d) {\n    return c * (t /= d) * t + b;\n  },\n  easeOut: function (t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n  },\n  easeInOut: function (t, b, c, d) {\n    if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n  },\n  expoEaseIn: function (t, b, c, d) {\n    return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n  },\n  expoEaseOut: function (t, b, c, d) {\n    return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n  },\n  expoEaseInOut: function (t, b, c, d) {\n    if (t == 0) return b;\n    if (t == d) return b + c;\n    if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n  }\n}\n\n// 编写animate类\nclass Animate {\n  constructor(dom) {\n    this.dom = dom;//dom元素\n    this.startTime = 0;// 开始时间\n    this.duration = null;//持续时间\n    this.startPos = 0;//开始位置\n    this.endPos = 0;//结束位置\n    this.propertyName = null;//dom样式,要改变的样式\n    this.easing = null;// 缓动算法\n  }\n  start(propertyName, endPos, duration, easing) {\n    this.startPos = this.dom.getBoundingClientRect()[propertyName]\n    this.startTime = new Date().getTime();\n    this.propertyName = propertyName;\n    this.endPos = endPos;\n    this.duration = duration;\n    this.easing = tween[easing];\n\n    const timeId = setInterval(() => {\n      if (this.step() === false) {\n        clearInterval(timeId);\n      }\n    }, 19)\n  }\n  //表示小球每一帧要做的事情\n  step() {\n    const t = new Date().getTime();\n    if (t >= this.startTime + this.duration) {\n      // 修正位置\n      this.update(this.endPos);\n      return false\n    }\n    const pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration);\n    this.update(pos)\n  }\n  update(pos) {\n    this.dom.style[this.propertyName] = pos + 'px'\n  }\n}\n\n// const div1 = document.querySelector('.box1');\n// const animate = new Animate(div1);\n// animate.start('left', 300, 2000, 'expoEaseOut');\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .box1 {\n      position: absolute;\n      background: blue;\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"box1\">我是div</div>\n\n\n  <script src=\"./3-策略模式实现动画.js\"></script>\n</body>\n\n</html>\n```\n\n#### 表单验证\n\n在以前我写的一个项目中有一个页面的表单有七八条，每一条都需要验证并提示对应信息并没有填写，当时的我就是写了大量的if语句来进行判断，现在想想使用策略模式实现是真的优雅。\n\n以下是一个较完整的表单验证：\n\n```js\nconst strategies = {\n  isNoEmpty(value, errMsg) {\n    if (value === '') {\n      return errMsg\n    }\n  },\n  minLength(value, min, errMsg) {\n    if (typeof value === 'string') {\n      if (value.length < min) {\n        return errMsg\n      }\n    }\n    else if (typeof value === 'number') {\n      if (value < min) {\n        return errMsg\n      }\n    }\n  },\n  isMobile(value, errMsg) {\n    if (!/^1[3-9]\\d{9}$/.test(value)) {\n      return errMsg;\n    }\n  }\n}\n\n// 实现validator类\nclass Validator {\n  // 保存校验规则\n  constructor() {\n    this.cache = [];\n  }\n  add(dom, rules) {\n    for (let i = 0, rule; rule = rules[i++];) {\n      const strategyAry = rule.strategy.split(':');\n      const errorMsg = rule.errMsg;\n      this.cache.push(function () {\n        console.log(strategyAry);\n        const strategy = strategyAry.shift();\n        strategyAry.unshift(dom.value);\n        strategyAry.push(errorMsg);\n        return strategies[strategy].apply(dom, strategyAry)\n      })\n    }\n  }\n  start() {\n    for (let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {\n      const errMsg = validatorFunc();\n      if (errMsg) {\n        return errMsg\n      }\n    }\n  }\n}\n\nconst form = document.getElementById('registerForm');\nfunction validatorFunc() {\n  const validator = new Validator();\n  validator.add(form.userName, [{\n    strategy: 'isNoEmpty',\n    errMsg: '用户名不能为空'\n  }, {\n    strategy: 'minLength:8',\n    errMsg: '不能小于8个数'\n  }]);\n  validator.add(form.password, [{\n    strategy: 'isNoEmpty',\n    errMsg: '密码不能为空'\n  }, {\n    strategy: 'minLength:8',\n    errMsg: '不能小于8个数'\n  }]);\n  validator.add(form.phoneNumber, [{\n    strategy: 'isNoEmpty',\n    errMsg: '手机号不能为空'\n  }, {\n    strategy: 'isMobile',\n    errMsg: '格式不正确'\n  }]);\n  return validator.start()\n}\n\nform.onsubmit = function () {\n  const errMsg = validatorFunc();\n  if (errMsg) {\n    alert(errMsg)\n    return false;\n  }\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <form action=\"#\" id=\"registerForm\">\n    <input type=\"text\" name=\"userName\">\n    <input type=\"password\" autocomplete name=\"password\">\n    <input type=\"text\" name=\"phoneNumber\">\n    <button>提交</button>\n  </form>\n  <!-- <script src=\"./4-表单验证.js\"></script> -->\n  <script src=\"./5-表单验证改.js\"></script>\n</body>\n\n</html>\n```\n\n当然可以在进一步修改下：\n\n```js\n//策略对象\nconst strategies = {\n  errorMsg(message, field = \"filed\") {\n    return message ?? `The ${field} not follow the rule: ${this.errorMsg.caller.name}`\n  },\n  required(value, { message, required: isEmpty }, filedname) {\n    if (isEmpty && value === '') {\n      return this.errorMsg(message, filedname)\n    }\n  },\n  max(value, { message, max: length, type }, filedname) {\n    if (type === \"string\" && value.length > length) {\n      return this.errorMsg(message, filedname);\n    }\n    if (type === \"number\" && Number(value) > length) {\n      return this.errorMsg(message, filedname);\n    }\n  },\n  min(value, { message, min: length, type = \"string\" }, filedname) {\n    if (type === \"string\" && value.length < length) {\n      return this.errorMsg(message, filedname);\n    }\n    if (type === \"number\" && Number(value) < length) {\n      return this.errorMsg(message, filedname);\n    }\n  },\n  parttern(value, { message, parttern: reg }, filedname) {\n    if (!reg.test(value)) {\n      return this.errorMsg(message, filedname);\n    }\n  }\n}\n\n// 实现validator类\nclass Validator {\n  // 保存校验规则\n  constructor(dom) {\n    this.dom = dom\n    this.cache = [];\n  }\n  add(filedname, rules) {\n    for (let i = 0, rule; rule = rules[i++];) {\n      const options = rule;\n      // 移除message/type等不是策略像项的key\n      const keys = Object.keys(options).filter(key => (key !== 'message' && key !== 'type'));\n      // 注意这里的策略像如果一个options写了多个只会对第一个生效\n\n      this.cache.push(() => {\n        if (!strategies?.[keys[0]]) {\n          throw new Error('请填写校验规则');\n        }\n        return strategies[keys[0]](this.dom?.[filedname]?.value, options, filedname)\n      })\n    }\n  }\n  start() {\n    for (let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {\n      const errMsg = validatorFunc();\n      console.log(errMsg);\n      if (errMsg) {\n        return errMsg\n      }\n    }\n  }\n}\n\nconst form = document.getElementById('registerForm');\nfunction validatorFunc() {\n  const validator = new Validator(form);\n  validator.add('userName', [{\n    required: true,\n    message: '用户名不能为空'\n  }, {\n    min: 8,\n    message: '不能小于8个数'\n  }]);\n  validator.add('password', [{\n    required: true,\n    message: '密码不能为空'\n  }, {\n    min: 8,\n    message: '密码不能小于8个数'\n  }]);\n  validator.add('phoneNumber', [{\n    required: true,\n    message: '手机号不能为空'\n  }, {\n    parttern: /^1[3-9]\\d{9}$/,\n    message: '格式不正确'\n  }]);\n  return validator.start()\n}\n\nform.onsubmit = function () {\n  const errMsg = validatorFunc();\n  if (errMsg) {\n    alert(errMsg)\n    return false;\n  }\n}\n```\n\n#### 总结\n\n通过这三个例子的演示我们可以看出策略模式有以下优点：\n\n- 策略模式利用委托，多态，组合等技术，有效的避免多重条件判断。\n- 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的strategies中，使得它们易于切换，易于理解，易于扩展。\n- 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。\n- 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。\n\n当然该模式也有一定的缺点：\n\n- 使用策略模式会在程序中增加许多策略类或者策略对象，这些算法不一定都会用到。\n- 用户必须了解所有的strategy，比如你出行会先选择很多交通工具，你必须要去了解所有交通工具的细节才能选择，这是违反最少知识原则的。\n\n当然在JavaScript中策略类往往是被函数代替的，这样也更加的灵活适用。\n\n### 代理模式\n\n定义：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。\n\n#### 虚拟代理\n\n代理其实还分保护代理和虚拟代理，保护代理用于控制不同权限的对象对目标对象的访问。但是在JavaScript中实现保护代理不是那么的容易，因为我们不知道是谁访问了对象。所以接下来讨论的都是虚拟代理。\n\n以下展示一个虚拟代理实现图片预加载：\n\n```js\nconst CreateImage = (\n  function () {\n    const imgNode = document.createElement('img');\n    document.body.appendChild(imgNode);\n    return {\n      setSrc(src) {\n        imgNode.width = 200\n        imgNode.src = src;\n        imgNode.alt = src\n      }\n    }\n  }()\n);\n\nconst imgUrl = 'https://avatars.githubusercontent.com/u/5378891?s=48&v=4'\n//CreateImage.setSrc('https://topzhang.cn/usr/assets/img/saber-header.jpg')\n\n\n// 引入代理对象\nconst proxyImage = (function () {\n  // 这里先创建一个img实例来异步加载图片，然后监听这个图片加载完毕后再将实际要展示图片的img容器地址替换为加载完的url，此时就直接从内存读取加载完的图片。\n  const img = new Image();\n  // 监听是否加载完\n  img.onload = function () {\n    CreateImage.setSrc(this.src)\n  }\n  return {\n    setSrc(src) {\n      CreateImage.setSrc('./image.png');\n      // 保存要加载的图片\n      img.src = src\n    }\n  }\n}())\nproxyImage.setSrc(imgUrl)\n```\n\n上面这段代码其实不使用代理也可以实现，但是我们尽量要求一个独享符合单一职责原则，不要吧过多的功能都揉合在一个对象上。而使用代理就可以将这两个功能粉离开，如果以后我们不需要预加载了修改起来也很方便，同时使用代理这里也遵循了接口一致，在使用上也很透明，不会增加用户的使用成本。\n\n#### 虚拟代理实现接口合并\n\n有很多的checkbox，点击一下checkbox就会发送一次网络请求，当用户频繁的点击就会频繁的发送网络请求，这对于性能的开销是非常大的。所以对于频繁的点击发送请求，我们可以先记录点击的checkbox，然后延迟一段时间后合并结果发出请求。其实就是做个防抖处理，就能极大的降低服务器的压力了。\n\n```js\nconst synchronousFile = function (id) {\n  console.log('开始同步', id, '文件')\n}\n\nconst checkboxs = document.getElementsByTagName('input');\nfor (let i = 0, c; c = checkboxs[i++];) {\n  c.onclick = function () {\n    if (this.checked = true) {\n      //synchronousFile(this.id)\n      proxySynchronousFile\n        (this.id)\n    }\n  }\n}\n\n// 这里我们点击一次checkbox就会同步一次，如果用户频繁的点击这会有性能瓶颈的\nconst proxySynchronousFile = (function () {\n  // 缓存\n  const cache = [];\n  let timer;\n  return function (id) {\n    cache.push(id);\n    if (timer) {\n      return;\n    }\n    timer = setTimeout(() => {\n      synchronousFile(cache.join(','));\n      clearTimeout(timer);\n      timer = null;\n      //清空数组\n      cache.length = 0\n    }, 2000)\n  }\n}());\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <input type=\"checkbox\" id=\"1\">\n  <input type=\"checkbox\" id=\"2\">\n  <input type=\"checkbox\" id=\"3\">\n  <input type=\"checkbox\" id=\"4\">\n  <input type=\"checkbox\" id=\"5\">\n  <input type=\"checkbox\" id=\"6\">\n  <input type=\"checkbox\" id=\"7\">\n  <input type=\"checkbox\" id=\"8\">\n  <input type=\"checkbox\" id=\"9\">\n  <input type=\"checkbox\" id=\"10\">\n  <script src=\"./2-虚拟代理合并http请求.js\"></script>\n</body>\n\n</html>\n```\n\n#### 虚拟代理实现惰性加载\n\n一个mini的打印控制台miniConsole.js。用户可以使用其log方法打印变量，然后按下f2就会在页面创建一个窗口显示打印信息。当然用户可能不会使用miniConsole，也可能不会按下f2打印结果，所以我们并不需要一开始就加载该js文件,我们可以在用户按下f2后在加载该文件，当然在那之前如果用户要使用log方法我们就需要先提供一个代理miniConsole对象提供代理的log方法保存用户实际要执行的log方法。\n\n```js\n// 这里是代理miniConsole 在用户还没按下f2前用于保存要执行的log函数，等到按下后新加载的log函数就会代替这个函数然后执行内部保存的函数\nlet miniConsole = (function () {\n  const cache = []\n  function handler(ev) {\n    console.log(cache);\n    if (ev.keyCode === 113) {\n      const script = document.createElement('script');\n      // 加载完真正的miniconsole然后执行\n      script.onload = function () {\n        for (let i = 0, fn; fn = cache[i++];) {\n          fn();\n        }\n      };\n      script.src = './miniConsole.js';\n      document.getElementsByTagName('head')[0].appendChild(script);\n      document.body.removeEventListener('keydown', handler, false)\n    }\n  }\n  document.body.addEventListener('keydown', handler, false);\n  return {\n    log(...args) {\n      cache.push(function () {\n        return miniConsole.log.apply(miniConsole, args)\n      })\n    }\n  }\n}());\n\nminiConsole.log(22)\nminiConsole.log(33)\n```\n\n#### 缓存代理\n\n```js\nfunction mult() {\n  console.log('开始计算乘积');\n  let a = 1;\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    a = a * arguments[i];\n  }\n  return a;\n}\n\n//添加缓存代理函数（当然该函数还可以讲话公共分布提取出来设置成一个通用的代理缓存工厂函数）\nconst proxyMult = (function () {\n  const cache = {};\n  return function (...args) {\n    const multArgs = args.join(',');\n    if (multArgs in cache) {\n      return cache[multArgs]\n    }\n    // 缓存\n    return cache[multArgs] = mult.apply(this, args);\n  }\n}())\n\nconsole.log(proxyMult(2, 3));\nconsole.log(proxyMult(2, 3));\n```\n\n#### 总结\n\n上述案例演示了代理的基本用法，实际上代理的使用方式有很多：\n\n- 防火墙代理 ----- 控制网络资源的访问\n- 远程代理 -----  为一个对象在不同的地址空间提供局部代表\n- 保护代理 ----- 用于对象有不同访问权限的情况\n- 智能引用代理 ----- 取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。\n- 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。\n\n代理模式可以让逻辑更加简洁清晰，使得对象的功能不再耦合。但是要注意我们在编写代码的时候实现不用可以的去使用代理模式，等到确实不方便访问某个对象的时候在写代理也不迟。\n\n### 迭代器模式\n\n定义：提供一个方顺序的访问目标对象中的各个元素，而又不需要暴露该对象的内部实现。\n\n目前大多数语言都内置了迭代器。\n\n#### 实现一个简单的迭代器\n\n```js\nconst each = function (ary, callback) {\n  for (let i = 0, l = ary.length; i < l; i++) {\n    callback.call(ary[i], ary[i], i)\n  }\n}\n\neach([1, 2, 3, 4, 5], function (item, index) {\n  console.log(item, index);\n})\n```\n\n#### 内部迭代器和外部迭代器\n\n迭代器可以分为内部迭代器和外部迭代器，在刚刚我们编写的each就是一个内部迭代器，外部只需要一次初始化调用即可。\n\n外部迭代器必须显式的请求迭代下一个元素，当然也增加了调用的复杂度，但是我们可以很方便的控制迭代过程。\n\n以下展示一个比较两个数组是否相等的案例：\n\n```js\n// 外部迭代\nclass Iterator {\n  constructor(obj) {\n    this.obj = obj;\n    this.current = 0;\n  }\n  next() {\n    this.current++;\n  }\n  done() {\n    return this.current >= this.obj.length\n  }\n  getCurrentItem() {\n    return this.obj[this.current]\n  }\n}\n\nconst i1 = new Iterator([1, 2, 3]);\nconst i2 = new Iterator([1, 2, 3]);\n\nfunction compare(i1, i2) {\n  if (i1.length !== i2.length) {\n    return false;\n  }\n  while (!i1.done() && !i2.done()) {\n    if (i1.getCurrentItem() !== i2.getCurrentItem()) {\n      return false;\n    }\n    i1.next();\n    i2.next();\n  }\n  return true;\n}\n\nconsole.log(compare(i1, i2));\n```\n\n#### 倒序迭代器\n\n分分钟实现：\n\n```js\nconst each = function (ary, callback) {\n  for (let i = ary.length; i >= 0; i--) {\n    callback.call(ary[i], ary[i], i)\n  }\n}\n\neach([1, 2, 3, 4, 5], function (item, index) {\n  console.log(item, index);\n});\n```\n\n#### 终止迭代器\n\n```js\nconst each = function (ary, callback) {\n  for (let i = 0, l = ary.length; i < l; i++) {\n\n    const res = callback.call(ary[i], ary[i], i)\n    if (res === false) {\n      break;\n    }\n  }\n}\n\neach([1, 2, 3, 4, 5], function (item, index) {\n  console.log(item);\n  if (item === 3) {\n    return false\n  }\n});\n```\n\n#### 总结\n\n迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。\n\n### 发布订阅模式\n\n定义：发布订阅模式又称之为观察者模式，定义对象之间的一对多的依赖关系，当一个对象的状态发生改变的时候所有依赖它的对象都会得到通知。\n\n当然发布订阅也是设计模式中最常见的一种模式了，其作用非常强大，现如今的前端框架，比如`React/Vue`中都能看到该模式，另外我在手写`Promise`源码的时候也用到了发布订阅模式，遇到复杂的跨组件传值情况也可以使用发布订阅来进行传递。\n总之该模式实用性很强，是个必须掌握的一个知识点。\n\n#### 基本的发布订阅器\n\n首先实现一个基本的发布订阅器，功能具备：\n\n1. 事件的监听，可以为一个事件类型添加多个函数进行监听。\n2. 事件的触发，触发事件会执行所有该事件的监听函数。\n3. 事件的移除，可以移除同一个事件的某一个监听函数，也可以移除某一个事件的所有监听函数。\n\n```js\nconst events = {\n  /*\n     保存事件的一个对象，基本结构为{key1:fn[],key2:fn[],...}\n     你也可以使用map代替普通的对象\n  */\n  eventList: {},\n  listen(key, fn) {\n    if (!this.eventList[key]) {\n      this.eventList[key] = []\n    }\n    this.eventList[key].push(fn);\n  },\n  trigger(key, ...args) {\n    fns = this.eventList[key];\n    if (!fns || fns.length === 0) {\n      return false;\n    }\n    for (let i = 0, fn; fn = fns[i++];) {\n      fn.apply(this, args)\n    }\n  }\n  ,\n  remove(key, fn) {\n    const fns = this.eventList[key];\n    // 如果用户没有传一个指定函数就删除该类型下的所有函数\n    if (!fns) {\n      return false\n    }\n    if (!fn) {\n      fns && (fns.length = 0)\n    } else {\n      for (let l = fns.length - 1; l >= 0; l++) {\n        const _fn = fns[l];\n        if (_fn === fn) {\n          fns.splice(l, 1);\n        }\n      }\n    }\n  }\n}\n```\n\n测试用例：\n\n```js\nevents.listen('home', function (price, square) {\n  console.log('价格', price);\n  console.log('面积', square);\n})\n\nevents.listen('home', function (price, square) {\n  console.log('面积', square);\n})\n\nevents.listen('home', function (price) {\n  console.log('价格', price);\n})\n\nevents.listen('car', function (price) {\n  console.log('car价格', price);\n})\nevents.remove('car')\n\nevents.trigger('home', 2000, 88)\nevents.trigger('car', 20010, 881)\n// 价格 2000\n// 面积 88\n// 面积 88\n// 价格 2000\n```\n\n上述代码实现了一个基本的发布订阅功能，接下来我们实现一个功能较为丰富的发布订阅器。\n\n#### 进阶的发布订阅器\n\n功能具备：\n\n1. 上述基本的所有功能。\n2. 支持单次监听，即该类型事件只会被监听一次。\n3. 唯一订阅，同类型下，唯一订阅前的所有非唯一订阅都会失效。\n4. 支持先发布后订阅。\n5. 支持类型订阅数量限制。\n6. 具有命名空间。\n\n说明：\n先发布后订阅功能，我们上面实现的基本发布订阅器，是需要执行订阅器，然后执行发布器触发，如果先发布的话，那是后续的订阅器是不会执行的了。而我们需要实现先执行发布类型事件（可以发布多个），然后后续遇到订阅了相同事件的订阅器就会执行先发布的类型事件，这里我们的逻辑就是只能触发一次先发布的类型事件。可以理解为离线消息只能被已读一次。\n\n命名空间则是考虑到大量使用发布订阅的情况，遇到了多个事件想使用同一个类型，所以可以加上一个命名空间来进行区分。\n\n```js\nclass MyEvent {\n  constructor() {\n    // 命名空间\n    this.namespaceCache = {};\n  }\n  // 默认的命名空间\n  static _default = \"default\"\n  //遍历执行函数的迭代器\n  static each(arr, fn) {\n    let ret;\n    for (let i = 0, l = arr.length; i < l; i++) {\n      const itemFn = arr[i];\n      ret = fn(itemFn, i)\n    }\n    return ret;\n  }\n  // 默认最大监听函数数量\n  static defaultMaxListeners = 5\n  // 设置最大监听函数数量\n  setMaxListeners(count) {\n    this._count = count\n  }\n  // 获取最大监听函数数量\n  getMaxListeners() {\n    return this._count ? this._count : MyEvent.defaultMaxListeners\n  }\n  // 基础的监听函数\n  _on(key, fn, cache) {\n    let fns = cache.get(key);\n    if (!fns) {\n      fns = [];\n    }\n    if (fns.length >= this.getMaxListeners()) {\n      return\n    }\n    fns.push(fn);\n    cache.set(key, fns);\n\n  }\n  _remove(key, fn, cache) {\n    let fns = cache.get(key);\n    //删除具体的函数\n    if (fn) {\n      for (let i = fns.length; i >= 0; i--) {\n        if (fns[i] === fn) {\n          fns.splice(i, 1);\n        }\n      }\n      // 没有传递就删除所有函数\n    } else {\n      fns && (fns.length = 0)\n    }\n  }\n  _emit(key, cache, ...args) {\n    const fns = cache.get(key);\n    if (!fns || !fns.length) {\n      return;\n    }\n    // 这里用箭头函数的话内部绑定的this就是无效的,另外这里封装一个迭代器是为了接受返回值\n    return MyEvent.each(fns, (itemFn) => {\n      return itemFn.apply(this, args);\n    });\n  }\n  // 创建命名空间\n  create(namespace = MyEvent._default) {\n    const cache = new Map();\n    // 保存先发布的的类型和参数数组，这是支持先发布后订阅功能关键\n    let offlineStack = [];\n    const childEvent = {\n      on: (key, fn, isLast = false) => {\n        this._on(key, fn, cache); \n        // 说明没有已经发布的了\n        if (offlineStack === null) {\n          return\n        }\n        // isLast 这个参数进行先发布后订阅生效，主要目的是后续的订阅只会对最后一个发布生效\n        if (isLast) {\n          offlineStack.length && offlineStack.pop()();\n        } else {\n          MyEvent.each(offlineStack, (itemFn) => {\n            itemFn()\n          })\n        }\n        // 订阅的时候只能执行一次预先的发布函数，后续的订阅就不执行了\n        offlineStack = null;\n      },\n      // 订阅的时候在这之前的所有订阅都会失效\n      one: (key, fn, isLast = false) => {\n        // 清除所有保存的订阅函数，只执行当前的\n        this._remove(key, null, cache);\n        childEvent.on(key, fn, isLast)\n      },\n      once: (key, fn, isLast) => {\n        const wrap = (...args) => {\n          fn.apply(this, args);\n          childEvent.remove(key, wrap)\n        }\n        childEvent.on(key, wrap, isLast)\n      },\n      remove: (key, fn) => {\n        this._remove(key, fn, cache);\n      },\n      emit: (key, ...args) => {\n        // 将参数保存\n        const fn = () => {\n          return this._emit.call(this, key, cache, ...args)\n        }\n        // 如果有说明存在还没被订阅就先发布了，所以保存在栈中\n        if (offlineStack) {\n          return offlineStack.push(fn);\n        }\n        // 否则就是正常订阅发布顺序，直接执行\n        return fn();\n      }\n    }\n    // 保存命名空间\n    return this.namespaceCache[namespace] ? this.namespaceCache[namespace] : this.namespaceCache[namespace] = childEvent\n  }\n  // 考虑没有设置命名空间的情况，返回代理方法\n  on(key, fn, isLast) {\n    const event = this.create();\n    event.on(key, fn, isLast)\n  }\n  one(key, fn, isLast) {\n    const event = this.create();\n    event.one(key, fn, isLast)\n  }\n  once(key, fn, isLast) {\n    const event = this.create();\n    event.once(key, fn, isLast)\n  }\n  emit(key, ...args) {\n    const event = this.create();\n    event.emit(key, ...args)\n  }\n  remove(key, fn) {\n    const event = this.create();\n    event.remove(key, fn)\n  }\n}\n\nmodule.exports = new MyEvent();\n```\n\n测试用例：\n\n```js\n// 这里默认最大监听数是 2\nEvent.on('car', (price) => {\n  console.log('汽车降价了', price)\n})\nEvent.on('car', (price) => {\n  console.log('汽车又降价了', price - 1000)\n})\n\nEvent.on('car', (price) => {\n  console.log('汽车内购价', price - 10000)\n})\n\nEvent.emit('car', 50000);\n// 汽车降价了 50000\n// 汽车又降价了 49000\n```\n\n```js\nEvent.setMaxListeners(5)\nEvent.on('car', (price) => {\n  console.log('汽车降价了', price)\n})\nEvent.on('car', (price) => {\n  console.log('汽车又降价了', price - 1000)\n})\n\nEvent.on('car', (price) => {\n  console.log('汽车内购价', price - 10000)\n})\n\n\nEvent.emit('car', 50000)\n// 汽车降价了 50000\n// 汽车又降价了 49000\n// 汽车内购价 40000\n```\n\n```js\n// 测试先发布订阅\nEvent.emit('car', 50000)\nEvent.on('car', (price) => {\n  console.log('汽车降价了', price)\n})\n\n// 后续的订阅不会触发\nEvent.on('car', (price) => {\n  console.log('汽车又降价了', price - 1000)\n})\n// 汽车降价了 50000\n```\n\n```js\n// 多个发布\nEvent.emit('car', 50000)\nEvent.emit('car', 50001)\nEvent.emit('car', 50002)\nEvent.on('car', (price) => {\n  console.log('汽车降价了', price)\n})\n\n// 后续的订阅不会触发\nEvent.on('car', (price) => {\n  console.log('汽车又降价了', price - 1000)\n})\n// 汽车降价了 50000\n// 汽车降价了 50001\n// 汽车降价了 50002\n```\n\n```js\n// 测试isLast\nEvent.emit('car', 50000)\nEvent.emit('car', 50001)\nEvent.emit('car', 50002)\nEvent.on('car', (price) => {\n  console.log('汽车降价了', price)\n}, true)\n\n// 后续的订阅不会触发\nEvent.on('car', (price) => {\n  console.log('汽车又降价了', price - 1000)\n})\n// 汽车降价了 50002\n```\n\n```js\n// 测试once\nEvent.on('car', (price) => {\n  console.log('常年促销', price)\n})\nEvent.once('car', (price) => {\n  console.log('汽车降价了', price)\n})\n\nEvent.emit('car', 50000)\nEvent.emit('car', 50000)\n// 常年促销 50000\n// 汽车降价了 50000\n// 常年促销 50000\n```\n\n```js\n// 测试唯一订阅，同类型下，唯一订阅前的所有非唯一订阅都会失效(同一命名空间下)\nEvent.setMaxListeners(5)\nEvent.on('car', (price) => {\n  console.log('常年促销1', price)\n})\nEvent.on('car', (price) => {\n  console.log('常年促销2', price)\n})\nEvent.on('car', (price) => {\n  console.log('常年促销3', price)\n})\nEvent.one('car', (price) => {\n  console.log('只有我能订阅', price)\n})\n\nEvent.emit('car', 50000)\nEvent.emit('car', 50000)\n// 只有我能订阅 50000\n// 只有我能订阅 50000\n```\n\n```js\n// 测试命名空间\nEvent.setMaxListeners(5)\nEvent.create('namespace1').on('car', (price) => {\n  console.log('常年促销1', price);\n})\nEvent.create('namespace2').on('car', (price) => {\n  console.log('常年促销2', price);\n})\nEvent.one('car', (price) => {\n  console.log('只有我能订阅', price);\n})\n\nEvent.emit('car', 50000);\nEvent.create('namespace1').emit('car', 50000);\nEvent.create('namespace2').emit('car', 50000);\n// 只有我能订阅 50000\n// 常年促销1 50000\n// 常年促销2 50000\n```\n\n#### 总结\n\n上述`Javascript`实现的的发布订阅模式其实还是和一些语言有一些不同。一些其他的语言相较`JavaScript`可能实现较为复杂，`JavaScript`可以将函数作为参数的特性，使得实现起来更加优雅和简单。\n发布订阅模式优点很明显，对于对象二者通信的结耦，在异步编程中也可以实现更加简洁松耦合的代码编写。\n但是该模式也不可避免的有一些缺点，毕竟发布订阅模式内部还是有闭包的存在，导致订阅者会一直存在内存中。另外我们过度的使用发布订阅会导致对象与对象之间的关系变得不可捉摸，同时多个发布订阅嵌套在一起导致的`bug`可能更加不可排查。\n\n一句话，合理利用，不可滥用。\n\n### 命令模式\n\n定义：将请求封装成一个对象，从而可以使用不同的请求让客户端参数化，对请求排队或者记录请求日志，可以提供请求的撤销和恢复。\n\n#### 传统的命令模式\n\n```js\nconst button1 = document.getElementById('button1');\nconst button2 = document.getElementById('button2');\nconst button3 = document.getElementById('button3');\n\nfunction setCommand(button, command) {\n  button.onclick = function () {\n    command.execute()\n  }\n}\n\nconst MenuBar = {\n  refresh() {\n    console.log('刷新菜单')\n  }\n}\n\nconst SubMenu = {\n  add() {\n    console.log('增加子菜单')\n  },\n  del() {\n    console.log('删除子菜单')\n  }\n}\n\nclass RefreshBarCommand {\n  constructor(receiver) {\n    this.receiver = receiver;\n  }\n\n  execute() {\n    this.receiver.refresh();\n  }\n}\n\nclass AddSubMenuCommand {\n  constructor(receiver) {\n    this.receiver = receiver\n  }\n  execute() {\n    this.receiver.add()\n  }\n}\n\nclass DelSubMenuCommand {\n  constructor(receiver) {\n    this.receiver = receiver\n  }\n  execute() {\n    this.receiver.del()\n  }\n}\n\nconst refreshMenuBarCommand = new RefreshBarCommand(MenuBar);\nconst addSubMenuCommmand = new AddSubMenuCommand(SubMenu);\nconst delSubMenuCommmand = new DelSubMenuCommand(SubMenu);\n\nsetCommand(button1, refreshMenuBarCommand);\nsetCommand(button2, addSubMenuCommmand);\nsetCommand(button3, delSubMenuCommmand);\n```\n\n将命令封装为一个对象然后提供一个公共的接口供执行命令的方法调用。这样就分离的命令的定义和执行的逻辑\n\n#### JavaScript命令模式\n\n```js\n// 可以不需要专门定义一个只执行execute的类，利用闭包也可以直接实现\nconst button1 = document.getElementById('button1');\nconst button2 = document.getElementById('button2');\nconst button3 = document.getElementById('button3');\n\nfunction setCommand(button, func) {\n  button.onclick = function () {\n    func()\n  }\n}\n\nconst MenuBar = {\n  refresh() {\n    console.log('刷新菜单')\n  }\n}\n\nconst SubMenu = {\n  add() {\n    console.log('增加子菜单')\n  },\n  del() {\n    console.log('删除子菜单')\n  }\n}\n\n// class RefreshBarCommand {\n//   constructor(receiver) {\n//     this.receiver = receiver;\n//   }\n\n//   execute() {\n//     this.receiver.refresh();\n//   }\n// }\n\n// class AddSubMenuCommand {\n//   constructor(receiver) {\n//     this.receiver = receiver\n//   }\n//   execute() {\n//     this.receiver.add()\n//   }\n// }\n\n// class DelSubMenuCommand {\n//   constructor(receiver) {\n//     this.receiver = receiver\n//   }\n//   execute() {\n//     this.receiver.del()\n//   }\n// }\n\n// const refreshMenuBarCommand = new RefreshBarCommand(MenuBar);\n// const addSubMenuCommmand = new AddSubMenuCommand(SubMenu);\n// const delSubMenuCommmand = new DelSubMenuCommand(SubMenu);\n\nsetCommand(button1, MenuBar.refresh);\nsetCommand(button2, SubMenu.add);\nsetCommand(button3, SubMenu.del);\n```\n\n可以看出灵活的JavaScript实现命令模式是十分简单的，当然如果你想更加规范的话，可以讲所有方法使用execute包裹一下，统一调用的接口。\n\n```js\n// 当然以execute来执行还是更能展现我们使用的是命令模式\n// 可以不需要专门定义一个只执行execute的类，利用闭包也可以直接实现\nconst button1 = document.getElementById('button1');\nconst button2 = document.getElementById('button2');\nconst button3 = document.getElementById('button3');\n\nfunction setCommand(button, command) {\n  button.onclick = function () {\n    command.execute();\n  }\n}\n\nfunction RefreshBarCommand(receiver) {\n  return {\n    execute() {\n      receiver.refresh();\n    }\n  }\n}\n\nconst MenuBar = {\n  refresh() {\n    console.log('刷新菜单')\n  }\n}\n\nconst SubMenu = {\n  add() {\n    console.log('增加子菜单')\n  },\n  del() {\n    console.log('删除子菜单')\n  }\n}\n\nconst refreshMenuBarCommand = RefreshBarCommand(MenuBar)\n\nsetCommand(button1, refreshMenuBarCommand);\n```\n\n#### 撤销命令\n\n这里利用到了策略模式使用的动画代码，用于演示开始动画并撤销动画的过程：\n\n```js\n// Animate.js\n\n/* \n * t: current time（当前时间）；当前时刻-开始时刻\n * b: beginning value（初始值）；初始位置\n * c: change in value（变化量）；目标位置-变化量\n * d: duration（持续时间）。\n*/\nconst tween = {\n  easeIn: function (t, b, c, d) {\n    return c * (t /= d) * t + b;\n  },\n  easeOut: function (t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n  },\n  easeInOut: function (t, b, c, d) {\n    if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n  },\n  expoEaseIn: function (t, b, c, d) {\n    return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n  },\n  expoEaseOut: function (t, b, c, d) {\n    return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n  },\n  expoEaseInOut: function (t, b, c, d) {\n    if (t == 0) return b;\n    if (t == d) return b + c;\n    if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n  }\n}\n\n// 编写animate类\nclass Animate {\n  constructor(dom) {\n    this.dom = dom;//dom元素\n    this.startTime = 0;// 开始时间\n    this.duration = null;//持续时间\n    this.startPos = 0;//开始位置\n    this.endPos = 0;//结束位置\n    this.propertyName = null;//dom样式,要改变的样式\n    this.easing = null;// 缓动算法\n  }\n  start(propertyName, endPos, duration, easing) {\n    this.startPos = this.dom.getBoundingClientRect()[propertyName]\n    this.startTime = new Date().getTime();\n    this.propertyName = propertyName;\n    this.endPos = endPos;\n    this.duration = duration;\n    this.easing = tween[easing];\n\n    const timeId = setInterval(() => {\n      if (this.step() === false) {\n        clearInterval(timeId);\n      }\n    }, 19)\n  }\n  //表示小球每一帧要做的事情\n  step() {\n    const t = new Date().getTime();\n    if (t >= this.startTime + this.duration) {\n      // 修正位置\n      this.update(this.endPos);\n      return false\n    }\n    const pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration);\n    this.update(pos)\n  }\n  update(pos) {\n    this.dom.style[this.propertyName] = pos + 'px'\n  }\n}\n```\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>带撤销的命令模式</title>\n    <style>\n      #ball {\n        top: 60px;\n        position: absolute;\n        background-color: #000;\n        width: 50px;\n        height: 50px;\n      }\n    </style>\n    <script src=\"../5-策略模式/3-策略模式实现动画.js\"></script>\n  </head>\n\n  <body>\n    <div id=\"ball\"></div>\n    请输入小球移动距离：<input\n      id=\"pos\"\n      placeholder=\"输入小球移动距离\"\n      type=\"text\"\n    />\n    <button id=\"moveBtn\">开始移动</button>\n    <button id=\"cancelBtn\">取消移动</button>\n  </body>\n  <script>\n    const ball = document.getElementById(\"ball\");\n    const pos = document.getElementById(\"pos\");\n    const moveBtn = document.getElementById(\"moveBtn\");\n    const cancelBtn = document.getElementById(\"cancelBtn\");\n\n    // moveBtn.onclick = function () {\n    //   const animate = new Animate(ball);\n    //   animate.start('left', pos.value, 1000, 'expoEaseIn')\n    // }\n\n    class MoveCommand {\n      constructor(receiver, pos) {\n        this.receiver = receiver;\n        this.pos = pos;\n        this.oldPos = null;\n      }\n      execute() {\n        this.receiver.start(\"left\", this.pos, 1000, \"expoEaseIn\");\n        // 记录小球开始的位置\n        this.oldPos =\n          this.receiver.dom.getBoundingClientRect()[this.receiver.propertyName];\n      }\n      undo() {\n        this.receiver.start(\"left\", this.oldPos, 1000, \"expoEaseIn\");\n      }\n    }\n    let moveCommand;\n    moveBtn.onclick = function () {\n      const animate = new Animate(ball);\n      moveCommand = new MoveCommand(animate, +pos.value);\n      moveCommand.execute();\n    };\n    cancelBtn.onclick = function () {\n      moveCommand.undo();\n    };\n  </script>\n</html>\n```\n\n用户点击开始按钮的时候会记录小球的开始位置并开始移动到指定位置,之后撤点击取消按钮就会返回原来的起点。\n\n#### 宏命令\n\n宏命令是一组命令的集合。我们将一组命令添加到命令执行对象中，然后遍历命令执行共同的接口（execute）\n\n```js\nconst closeDoorCommand = {\n  execute() {\n    console.log('关门')\n  }\n}\n\nconst openPcCommand = {\n  execute() {\n    console.log('关电脑')\n  }\n}\n\nconst openQQCommand = {\n  execute() {\n    console.log('登陆qq')\n  }\n}\n\nclass MacroCommand {\n  constructor() {\n    this.commandsList = []\n  }\n  add(command) {\n    this.commandsList.push(command)\n  }\n  execute() {\n    for (const command of this.commandsList) {\n      command.execute();\n    }\n  }\n}\n\nconst macroCommand = new MacroCommand();\n\nmacroCommand.add(closeDoorCommand);\nmacroCommand.add(openPcCommand);\nmacroCommand.add(openQQCommand);\nmacroCommand.execute()\n```\n\n#### 小结\n\n可以看到在JavaScript中命令模式实现起来更加简洁，可以利用高阶函数实现该模式。命令模式在JavaScript中也算事一种隐形的模式。\n\n#### 组合模式\n\n定义：用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。\n\n回顾之前定义的宏命令，我们可以看出，整个宏命令和子命令是成树形结构的。相比子命令，宏命令就相当于是子命令的代理。\n\n另外组合模式还可以利用多态来实现递归执行，比如子命令又是一个很多子命令的集合。我们只需要调用公共的执行接口（execute）就能传播执行所有命令。\n\n一个更强大的宏命令：\n\n```js\nclass MacroCommand {\n  constructor() {\n    this.commandsList = []\n  }\n  add(command) {\n    this.commandsList.push(command)\n  }\n  execute() {\n    for (const command of this.commandsList) {\n      command.execute();\n    }\n  }\n}\n\nconst openAcCommand = {\n  execute() {\n    console.log('打开空调')\n  }\n}\n\nconst openTvCommand = {\n  execute() {\n    console.log('打开电视')\n  }\n}\n\nconst openSoundCommand = {\n  execute() {\n    console.log('打开音响')\n  }\n}\n\nconst macroCommand1 = new MacroCommand();\nmacroCommand1.add(openSoundCommand);\nmacroCommand1.add(openTvCommand)\n\n\nconst closeDoorCommand = {\n  execute() {\n    console.log('关门')\n  }\n}\n\nconst openPcCommand = {\n  execute() {\n    console.log('关电脑')\n  }\n}\n\nconst openQQCommand = {\n  execute() {\n    console.log('登陆qq')\n  }\n}\n\n\nconst macroCommand2 = new MacroCommand();\nmacroCommand2.add(closeDoorCommand);\nmacroCommand2.add(openPcCommand);\nmacroCommand2.add(openQQCommand);\n\n// 组装一个超级宏命令\nconst macroCommand = new MacroCommand();\n\nmacroCommand.add(openAcCommand);\nmacroCommand.add(macroCommand1);\nmacroCommand.add(macroCommand2);\n\nconst button = document.getElementById('button')\n\nconst setCommand = function (dom, command) {\n  dom.onclick = function () {\n    command.execute();\n  }\n}\n\nsetCommand(button, macroCommand)\n```\n\n当然我们要注意，执行子命令的父命令往往都有add方法，用于添加子命令，但是作为叶子结点的子命令是没有添加命令的方法的，所以为了避免用户误操作，保证透明性，我们可以可以在子命令中添加add方法，内部抛出异常即可。\n\n```js\nconst xxxCommand = {\n  execute() {\n    console.log('打开空调')\n  }\n  add(){\n    throw new Error('子命令不能添加命令')\n  }\n}\n```\n\n#### 扫描文件夹\n\n文件和文件夹之间的关系非常适合用组合模式来进行模拟，我们访问扫描文件的时候并不需要关心其内部有多少文件或文件夹，只需要从最外层文件扫描，自动进行递归扫描所有文件。\n\n```js\nclass Folder {\n  constructor(name) {\n    this.name = name;\n    this.files = [];\n  }\n  add(file) {\n    this.files.push(file)\n  }\n  scan() {\n    console.log('开始扫描文件夹---' + this.name)\n    for (const file of this.files) {\n      file.scan();\n    }\n  }\n}\n\nclass File {\n  constructor(name) {\n    this.name = name\n  }\n  add() {\n    throw new Error('文件下面不能添加文件')\n  }\n  scan() {\n    console.log('开始扫描文件---' + this.name)\n  }\n}\n\nconst folder = new Folder('学习资料');\n\nconst folder1 = new Folder('JavaScript')\nconst folder2 = new Folder('JQuery')\nconst file1 = new File('JavaScript设计模式与开发实践')\nconst file2 = new File('精通JQuery')\nconst file3 = new File('重构与模式');\n\n\nfolder1.add(file1);\nfolder2.add(file2);\nfolder.add(folder1);\nfolder.add(folder2);\nfolder.add(file3);\n\nconst folder3 = new Folder('NodeJs');\nconst file4 = new File('深入浅出Node.js');\nfolder3.add(file4)\n\nconst file5 = new File('JavaScript语言精髓与编程实践');\nfolder.add(folder3);\nfolder.add(file5);\nfolder.scan()\n```\n\n可以看到我们只需执行最顶端的scan方法就可以扫描其下所有的文件/文件夹了。\n\n另外注意组合模式子命令和父命令这种树形结构关系并不是父子关系，（为了方便我们才这样称呼）组合模式是一种HAS-A（聚合）的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。\n\n#### 引用父对象\n\n有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。\n\n```js\nclass Folder {\n  constructor(name) {\n    this.name = name;\n    this.files = [];\n    this.parent = null;\n  }\n  add(file) {\n    // 设置父对象\n    file.parent = this;\n    this.files.push(file)\n  }\n  scan() {\n    console.log('开始扫描文件夹---' + this.name)\n    for (const file of this.files) {\n      file.scan();\n    }\n  }\n  remove() {\n    if (!this.parent) {\n      // 根结点或者还没添加的游离节点\n      return\n    }\n    for (let files = this.parent.files, l = files.length - 1; l >= 0; l--) {\n      const file = files[l];\n      //从父文件中找到自己，然后滚蛋\n      if (file === this) {\n        console.log('移除文件夹---' + this.name);\n        files.splice(l, 1)\n      }\n    }\n  }\n}\n\nclass File {\n  constructor(name) {\n    this.name = name\n    this.parent = null;\n  }\n  add() {\n    throw new Error('文件下面不能添加文件')\n  }\n  scan() {\n    console.log('开始扫描文件---' + this.name)\n  }\n  remove() {\n    if (!this.parent) {\n      // 根结点或者还没添加的游离节点\n      return\n    }\n    for (let files = this.parent.files, l = files.length - 1; l >= 0; l--) {\n      const file = files[l];\n      //从父文件中找到自己，然后滚蛋\n      if (file === this) {\n        console.log('移除文件---' + this.name)\n        files.splice(l, 1)\n      }\n    }\n  }\n}\n\nconst folder = new Folder('学习资料');\n\nconst folder1 = new Folder('JavaScript')\nconst folder2 = new Folder('JQuery')\nconst file1 = new File('JavaScript设计模式与开发实践')\nconst file2 = new File('精通JQuery')\nconst file3 = new File('重构与模式');\n\n\nfolder1.add(file1);\nfolder2.add(file2);\nfolder.add(folder1);\nfolder.add(folder2);\nfolder.add(file3);\n\nconst folder3 = new Folder('NodeJs');\nconst file4 = new File('深入浅出Node.js');\nfolder3.add(file4)\n\nconst file5 = new File('JavaScript语言精髓与编程实践');\nfolder.add(folder3);\nfolder.add(file5);\nfolder.scan()\n\n// 移除文件/夹\nfolder1.remove()\nfile5.remove()\n\nfolder.scan()\n```\n\n#### 总结\n\n组合模式适用于以下两种情况：\n\n- 表示对象的部分-整体层次结构。\n- 客户希望统一对待树中的所有对象。\n\n组合模式可以让我们使用树形方式创建对象的结构。我们可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。\n\n当然也有一定的缺点，大量的使用组模式会导致创建出来的对象之前区别不是很大，其区别只有在运行的时候才会显示出来，这会使代码难以理解。另外过多的使用组合模式创建大量的对象也会对代码性能瓶颈造成影响。\n\n### 模版方法模式\n\n含义：平行的各个子类之间有一些相同的行为，也有一些不同的行为。该模式就是将各个子类相同的行为单独提取出来进行复用。\n\n模版方法模式其实就是只需继承就可以实现的一种简单的模式。模版方法模式一般有两个部分组成，一部分是抽象类，第二部分是具体的实现子类。\n\n#### 泡饮料\n\n```js\nclass Beverage {\n\n  boilWater() {\n    console.log('把水煮沸')\n  }\n  brew() {\n    // 子类重写\n  }\n  pourInCup() {\n    //空方法\n  }\n  addCondiments() {\n    // 空方法\n  }\n  // 模版方法\n  init() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    this.addCondiments();\n  }\n}\n\nclass Coffee extends Beverage {\n  brew() {\n    console.log('沸水泡咖啡')\n  }\n  pourInCup() {\n    console.log('把咖啡倒进杯子')\n  }\n  addCondiments() {\n    console.log('加牛奶')\n  }\n}\n\nconst coffee = new Coffee();\ncoffee.init();\n\nclass Tea extends Beverage {\n  brew() {\n    console.log('沸水浸泡咖啡')\n  }\n  pourInCup() {\n    console.log('把茶叶倒进杯子')\n  }\n  addCondiments() {\n    console.log('加柠檬')\n  }\n}\n\nconst tea = new Tea();\n//tea.init();\n```\n\n上述的模版方法就是init，内部执行函数顺序一样，只是不同的子类对函数有不同的实现。\n\n#### 抽象类\n\n由于JavaScript没有抽象类的概念（你可以使用TypeScript），所以我们在使用模版方法可能会遇到一些问题。\n\n比如：子类忘记实现父类方法。\n\n当然这里有几种解决方法：\n\n- 使用鸭子类型来检测子类是否有实现方法，但是这实现起来比较的复杂而且也加入 了很多与业务无关的代码\n- 在父类方法中抛出异常，如果子类没重写那就会报错。\n\n当然第二种方式是最简单的，但用户要得到消息需要等到执行代码的时候。\n\n#### 钩子方法\n\n```js\nclass Beverage {\n\n  boilWater() {\n    console.log('把水煮沸')\n  }\n  brew() {\n    // 子类重写\n  }\n  pourInCup() {\n    //空方法\n  }\n  addCondiments() {\n    // 空方法\n  }\n  customerWantsComdiments() {\n    // 默认需要\n    return true;\n  }\n  // 模版方法\n  init() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    if (this.customerWantsComdiments()) {\n      this.addCondiments();\n    }\n\n  }\n}\n\nclass Coffee extends Beverage {\n  brew() {\n    console.log('沸水泡咖啡')\n  }\n  pourInCup() {\n    console.log('把咖啡倒进杯子')\n  }\n  customerWantsComdiments() {\n    // 默认需要\n    return window.confirm('需要调料吗');\n  }\n  addCondiments() {\n    console.log('加牛奶')\n  }\n}\n\nconst coffee = new Coffee();\ncoffee.init();\n\nclass Tea extends Beverage {\n  brew() {\n    console.log('沸水浸泡咖啡')\n  }\n  pourInCup() {\n    console.log('把茶叶倒进杯子')\n  }\n  addCondiments() {\n    console.log('加柠檬')\n  }\n}\n\nconst tea = new Tea();\ntea.init();\n```\n\n在父类添加一个钩子方法用户动态的控制函数执行步骤，并交给子类来重写实现。这样我们的代码就有了更多的可能了。\n\n#### 总结\n\n传统语言的模版方法往往需要子父类继承实现，我们把变化的逻辑放置在子类中，父类只保留不变的，也可以内置一个钩子来实现修改父类。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。\n\n当然JavaScript还可以利用高阶函数方式来实现，这会更加的灵活。\n\n### 享元模式\n\n含义：运用共享技术来有效支持大量细粒度的对象。\n\n该模式主要用于性能上的优化。\n\n工厂生产了男女内衣格50件，但是每件的型号各不相同（不是size，而是style），正常情况需要50个男模特和50个女模特来试穿，每个模特穿一个内衣后进行拍照。但如果以后工厂生产了一万种，那难道还会找一万个模特吗，这显然开销太大了。其实我们考虑内衣大类型上只区分男女信号，所以理论上来讲只需要找一个男模特和一个女模特来穿不同的内衣试穿即可。\n\n所以代码演示如下：\n\n```js\nclass Model {\n  constructor(sex) {\n    this.sex = sex;\n  }\n  takePhoto() {\n    console.log(this.sex + '模特穿' + this.underwear + '号内衣')\n  }\n}\n\nconst femaleModel = new Model('female');\nconst maleModel = new Model('male');\nfor (let i = 1; i <= 50; i++) {\n  maleModel.underwear = i\n  maleModel.takePhoto();\n}\n\n\nfor (let i = 1; i <= 50; i++) {\n  femaleModel.underwear = i;\n  femaleModel.takePhoto();\n}\n```\n\n享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量。\n\n对于如何划分内部状态和外部状态，有以下方式：\n\n- 内部状态存储于对象内部。\n- 内部状态可以被一些对象共享。\n- 内部状态独立于具体的场景，通常不会改变。\n- 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。\n\n这里我们得出上面例子中，性别是内部状态，内衣是外部状态。一般来讲内部状态有几种我们就需要创建几种对象。而无论那种衣服都分有男女，所以其性别是一个可以共享的内部状态，而衣服每件都是不同的，所以划分为外部状态。\n\n#### 对象爆炸\n\n对于文件上传，如果我们选取一个文件就创建一个文件对象进行上传处理，那当遇到大量文件上传的时候是十分消耗性能的。我我有时就会上传上前上万的文件。\n\n```js\nlet id = 0;\n\nclass Upload {\n  constructor(uploadType, fileName, fileSize) {\n    this.uploadType = uploadType;\n    this.fileName = fileName;\n    this.fileSize = fileSize;\n    this.dom = null;\n  }\n  init(id) {\n    this.id = id;\n    this.dom = document.createElement(\"div\");\n    this.dom.innerHTML = `\n    <span>文件名称：${this.fileName}, 文件大小：${this.fileSize}</span>\n    <button class=\"del-file\">删除</button>\n    `;\n    this.dom.querySelector(\".del-file\").onclick = () => {\n      this.delFile();\n    };\n\n    document.body.appendChild(this.dom);\n  }\n  delFile() {\n    if (this.fileSize < 3000) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n    if (window.confirm(\"确认要删除该文件吗? \" + this.fileName)) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n  }\n}\n\nfunction startUpload(uploadType, files) {\n  for (let i = 0, file; (file = files[i++]); ) {\n    const uploadObj = new Upload(uploadType, file.fileName, file.fileSize);\n    uploadObj.init(id++);\n  }\n}\n\n//分别创建插件上传对象和flash上传对象\nstartUpload(\"plugin\", [\n  {\n    fileName: \"1.txt\",\n    fileSize: 1000,\n  },\n  {\n    fileName: \"2.txt\",\n    fileSize: 3001,\n  },\n  {\n    fileName: \"3.txt\",\n    fileSize: 10000,\n  },\n  {\n    fileName: \"4.txt\",\n    fileSize: 2000,\n  },\n]);\n\nstartUpload(\"flash\", [\n  {\n    fileName: \"11.txt\",\n    fileSize: 1000,\n  },\n  {\n    fileName: \"22.txt\",\n    fileSize: 3001,\n  },\n  {\n    fileName: \"33.txt\",\n    fileSize: 10000,\n  },\n  {\n    fileName: \"44.txt\",\n    fileSize: 2000,\n  },\n]);\n```\n\n可以看到我们分为两种上传方式，但是每一种都是添加一个文件，就新建一个上传对象。如果遇到了大量的文件，那势必会造成对象爆炸。\n\n我们接下来可以通过享元模式改善上述代码。\n\n#### 优化对象爆炸\n\n```js\nlet id = 0;\n\n\n\nclass Upload {\n  constructor(uploadType,) {\n    this.uploadType = uploadType;\n  }\n  delFile(id) {\n    uploadManager.setExternalState(id, this);\n    if (this.fileSize < 3000) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n    if (window.confirm('确认要删除该文件吗? ' + this.fileName)) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n  }\n}\n\n\n\n// 创建和保存享元对象的工厂类吗，保证一个类型的对象只创建了一个\nclass UpLoadFactory {\n  constructor() {\n    this.createFlyWeightObj = {};\n  }\n  create(uploadType) {\n    if (this.createFlyWeightObj[uploadType]) {\n      return this.createFlyWeightObj[uploadType]\n    }\n    return this.createFlyWeightObj[uploadType] = new Upload(uploadType)\n  }\n}\n\n\n\n\n// 保存外部环境的类\nclass UploadManager {\n  constructor() {\n    this.uploadDatabase = {};\n  }\n  add(id, uploadType, fileName, fileSize) {\n    // 这里创建就只会创建特定类型的上传对象了\n    let flyWeightObj = upLoadFactory.create(uploadType);\n    const dom = document.createElement('div');\n    dom.innerHTML = `\n    <span>文件名称：${fileName}, 文件大小：${fileSize}</span>\n    <button class=\"del-file\">删除</button>\n    `\n    dom.querySelector('.del-file').onclick = () => {\n      flyWeightObj.delFile(id);\n    }\n    document.body.appendChild(dom);\n\n    // 存储到上传管理对象中\n    this.uploadDatabase[id] = {\n      fileName,\n      fileSize,\n      dom\n    }\n    return flyWeightObj;\n  }\n  // 给享元对象添加外部状态\n  setExternalState(id, flyWeightObj) {\n    const uploadData = this.uploadDatabase[id];\n    for (const i in uploadData) {\n      flyWeightObj[i] = uploadData[i]\n    }\n  }\n}\n\nconst uploadManager = new UploadManager();\nconst upLoadFactory = new UpLoadFactory();\n\n\n\nfunction startUpload(uploadType, files) {\n  for (let i = 0, file; file = files[i++];) {\n    uploadManager.add(++id, uploadType, file.fileName, file.fileSize);\n  }\n}\n\n//分别创建插件上传对象和flash上传对象\nstartUpload('plugin', [\n  {\n    fileName: '1.txt',\n    fileSize: 1000\n  },\n  {\n    fileName: '2.txt',\n    fileSize: 3001\n  },\n  {\n    fileName: '3.txt',\n    fileSize: 10000\n  },\n  {\n    fileName: '4.txt',\n    fileSize: 2000\n  }\n])\n\nstartUpload('flash', [\n  {\n    fileName: '11.txt',\n    fileSize: 1000\n  },\n  {\n    fileName: '22.txt',\n    fileSize: 3001\n  },\n  {\n    fileName: '33.txt',\n    fileSize: 10000\n  },\n  {\n    fileName: '44.txt',\n    fileSize: 2000\n  }\n])\n\nconsole.log(upLoadFactory.createFlyWeightObj);\n```\n\n可以看到我们将上传的一些参数分为了内部状态和外部状态，上传的方式我们作为内部状态，此时就创建了两个对象，而上传的名字，大小，这些参数各个文件都是不同的，并不能共享，所以作为外部状态，当然最后还需要一个关系对象将这两种状态关系起来。通过这样的优化，我们创建的对象始终为两个。\n\n#### 对象池\n\n对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待被下次获取。\n\n这里以一个地图气泡作为例子，我们使用的地图的上会使用到游戏额tooltips，作为地点的提示，这些tips就可以通过对象池进行管理。比如当我们在第一个地点的时候显示4个tips，而在第二个地点的时候需要显示2个tips，我们切换到第二个地点的时候并不需要重新新建两个dom作为tips，而是从之前创建的四个tips dom取出两个复用即可。\n\n```js\nclass ToolTipFactory {\n  constructor() {\n    this.toolTipPool = []\n  }\n  // 获取\n  create() {\n    if (this.toolTipPool.length === 0) {\n      console.log('创建6个div执行了几次');\n      const div = document.createElement('div');\n      document.body.appendChild(div);\n      return div;\n    } else {\n      return this.toolTipPool.shift();\n    }\n  }\n  // 回收\n  recover(tooltipDom) {\n    return this.toolTipPool.push(tooltipDom)\n  }\n}\n\nconst toolTipFactory = new ToolTipFactory();\n\n// 保存已经创建的节点\nconst ary = []\n\nfor (let i = 0, str; str = ['A', 'B'][i++];) {\n  const toolTip = toolTipFactory.create();\n  toolTip.innerHTML = str;\n  ary.push(toolTip);\n}\n\n//回收节点\nfor (let i = 0, dom; dom = ary[i++];) {\n  toolTipFactory.recover(dom);\n}\n\n// 再次创建\nfor (let i = 0, str; str = ['A1', 'B2', 'C', 'D', 'E', 'F'][i++];) {\n  const toolTip = toolTipFactory.create();\n  toolTip.innerHTML = str;\n  ary.push(toolTip);\n}\n```\n\n#### 通用对象池\n\n之前的dom复用对象池我们可以将公共的逻辑抽离出来，编写一个公共的对象池：\n\n```js\nclass ObjectPoolFactory {\n  constructor(createObjFn) {\n    this.objectPool = [];\n    this.createObjFn = createObjFn;\n  }\n  create(...args) {\n    const obj = this.objectPool.length === 0 ?\n      this.createObjFn.apply(...args) :\n      this.objectPool.shift();\n\n    return obj;\n  }\n  recover(obj) {\n    this.objectPool.push(obj);\n  }\n}\n\n// 创建一些iframe的对象池\n\nconst iframeFactory = new ObjectPoolFactory(function () {\n  const iframe = document.createElement('iframe');\n  document.body.appendChild(iframe);\n  iframe.onload = function () {\n    iframe.onload = null;\n    // 加载完成后就回收\n    iframeFactory.recover(iframe);\n  }\n  return iframe;\n});\n\nconst iframe1 = iframeFactory.create();\niframe1.src = 'http://music.topzhang.cn'\n\nconst iframe2 = iframeFactory.create();\niframe2.src = 'http://topzhang.cn';\n\nconst iframe3 = iframeFactory.create();\niframe3.src = 'https://altria.topzhang.cn';\n\n\n// 切换一个展示\nsetTimeout(() => {\n  iframe4 = iframeFactory.create();\n  iframe4.src = \"http://music.163.com\"\n}, 3000)\n\n\nsetTimeout(() => {\n  console.log(iframeFactory.objectPool);\n}, 9000)\n```\n\n#### 总结\n\n享元模式是一种很好的性能优化方案，在以下情况可以使用享元模式进行优化：\n\n- 一个程序中使用了大量的相似对象。\n- 使用了大量的对象造成了内存开销过大。\n- 对象的大多数状态可以作为外部属性抽离出来。\n- 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。\n\n对象池其实是一种没有分离内外部状态的性能优化模式，和享元模式相似。所以上传文件的那个案例还可以使用对象池加事件委托来实现。\n\n#### 责任链模式\n\n含义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n#### 计算优惠卷\n\n购物的时候会根据用户是否支付定金，定金数额，来计算给用户优惠多少。这里就许哟啊大量的额条件判断语句进行判断。可能我们第一次想的代码是如下的：\n\n```js\nfunction order(orderType, pay, stock) {\n  if (orderType === 1) {\n    if (pay === true) {\n      console.log('500元定金，得到优惠卷')\n    } else {\n      if (stock > 0) {\n        console.log('普通购买无优惠卷')\n      } else {\n        console.log('没库存')\n      }\n    }\n  } else if (orderType === 2) {\n    if (pay === true) {\n      console.log('200元定金，得到优惠卷')\n    } else {\n      if (stock > 0) {\n        console.log('普通购买无优惠卷')\n      } else {\n        console.log('没库存')\n      }\n    }\n  } else {\n    if (stock > 0) {\n      console.log('普通购买无优惠卷')\n    } else {\n      console.log('没库存')\n    }\n  }\n}\n\norder(3, true, 0)\n```\n\n如果我们后续再加上一些其他条件，那这个条件判断会越来越庞大，倒是维护起来容易出错。\n\n#### 责任链模式重构\n\n首先将之前的一些逻辑分离出来，放到一个单独函数中：\n\n```js\nfunction order500(orderType, pay, stock) {\n  if (orderType === 1 && pay === true) {\n    console.log('500元定金')\n  } else {\n    order200(orderType, pay, stock)\n  }\n}\n\n\nfunction order200(orderType, pay, stock) {\n  if (orderType === 2 && pay === true) {\n    console.log('200元定金')\n  } else {\n    orderNormal(orderType, pay, stock)\n  }\n}\n\n\nfunction orderNormal(orderType, pay, stock) {\n  if (stock > 0) {\n    console.log(\"普通购买\")\n  } else {\n    console.log('没了')\n  }\n}\n\norder500(1, true, 0)\n```\n\n接下来结合责任链进行改造：\n\n```js\nfunction order500(orderType, pay, stock) {\n  if (orderType === 1 && pay === true) {\n    console.log('500元定金')\n  } else {\n    return 'next'\n  }\n}\n\n\nfunction order200(orderType, pay, stock) {\n  if (orderType === 2 && pay === true) {\n    console.log('200元定金')\n  } else {\n    return 'next'\n  }\n}\n\nfunction order300(orderType, pay, stock) {\n  if (orderType === 4 && pay === true) {\n    console.log('300元定金')\n  } else {\n    return 'next'\n  }\n}\n\n\nfunction orderNormal(orderType, pay, stock) {\n  if (stock > 0) {\n    console.log(\"普通购买\")\n  } else {\n    console.log('没了 -----')\n  }\n}\n\nclass Chain {\n  constructor(fn) {\n    this.fn = fn;\n    this.successor = null;\n  }\n  setNextSuccessor(successor) {\n    // 指定下一个节点\n    return this.successor = successor;\n  }\n  passRequest(...args) {\n    // 传递给某个节点\n    const ret = this.fn(...args);\n    // 处理不了\n    if (ret === 'next') {\n      return this.successor &&\n        this.successor.passRequest.apply(this.successor, args)\n    }\n    return ret;\n  }\n}\n\nconst chainOrder500 = new Chain(order500);\nconst chainOrder200 = new Chain(order200);\nconst chainOrder300 = new Chain(order300);\nconst chainOrderNormal = new Chain(orderNormal);\n\nchainOrder500\n  .setNextSuccessor(chainOrder200)\n  .setNextSuccessor(chainOrder300)\n  .setNextSuccessor(chainOrderNormal);\n\nchainOrder500.passRequest(1, true, 500)\nchainOrder500.passRequest(1, false, 500)\nchainOrder500.passRequest(1, false, 0)\n\nchainOrder500.passRequest(2, true, 500)\nchainOrder500.passRequest(2, false, 500)\nchainOrder500.passRequest(2, false, 0)\nchainOrder500.passRequest(4, true, 500)\nchainOrder500.passRequest(4, false, 500)\nchainOrder500.passRequest(4, false, 0)\n\nchainOrder500.passRequest(3, true, 500)\nchainOrder500.passRequest(3, false, 500)\nchainOrder500.passRequest(3, false, 0)\n```\n\n现在我们再加上条件的话就不用在一个地方写条件判断了，只需要新增一个逻辑判断函数和连接就行了。\n\n#### AOP实现责任链\n\n我们还可以结合之前写的AOP函数对责任链对象进行替换：\n\n```js\nfunction order500(orderType, pay, stock) {\n  if (orderType === 1 && pay === true) {\n    console.log('500元定金')\n  } else {\n    return 'next'\n  }\n}\n\n\nfunction order200(orderType, pay, stock) {\n  if (orderType === 2 && pay === true) {\n    console.log('200元定金')\n  } else {\n    return 'next'\n  }\n}\n\nfunction order300(orderType, pay, stock) {\n  if (orderType === 4 && pay === true) {\n    console.log('300元定金')\n  } else {\n    return 'next'\n  }\n}\n\n\nfunction orderNormal(orderType, pay, stock) {\n  if (stock > 0) {\n    console.log(\"普通购买\")\n  } else {\n    console.log('没了 -----')\n  }\n}\n\nFunction.prototype.after = function (fn) {\n  return (...args) => {\n    const ret = this.apply(null, args);\n    if (ret === 'next') {\n      return fn.apply(null, args);\n    }\n    return ret;\n  }\n}\n\n\nconst order = order500\n  .after(order300)\n  .after(order200)\n  .after(orderNormal);\n\norder(1, true, 500)\norder(1, false, 500)\norder(1, false, 0)\n\norder(2, true, 500)\norder(2, false, 500)\norder(2, false, 0)\n\norder(4, true, 500)\norder(4, false, 500)\norder(4, false, 0)\n\norder(3, true, 500)\norder(3, false, 500)\norder(3, false, 0)\n```\n\n#### 总结\n\n责任链的有带你就是解耦了请求者和N个接收者之间的复杂关系，但是职责链也会使\n\n程序中多出一些节点对象，过长的对象链可能会造成性能上的损失。另外，用AOP来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能也有较大的影响。\n\n### 中介者模式\n\n含义：解耦对象与对象之间的紧耦合关系，使得多对多关系变成了相对简单的一对多关系。\n\n#### 泡泡堂两人游戏\n\n玩家数量就两个，一个死亡后就会通知自己失败，另一个胜利：\n\n```js\nclass Player {\n  constructor(name) {\n    this.name = name;\n    this.enemy = null;//敌人\n  }\n  win() {\n    console.log(this.name + ' won!');\n  }\n  lose() {\n    console.log(this.name + ' lost!');\n  }\n  die() {\n    this.lose();\n    this.enemy.win();\n  }\n}\n\nconst player1 = new Player('皮蛋');\nconst player2 = new Player('小乖');\n\n// 设置敌人\nplayer1.enemy = player2;\nplayer2.enemy = player1;\n\nplayer1.die();\nplayer2.die()\n```\n\n#### 八人对战的游戏\n\n上面的游戏是两人，但如果我们将队伍加至八人，并且分为两队每队个4人，这时候该如何设置关系：\n\n```js\n// 所有的玩家\nconst players = [];\n\nclass Player {\n  constructor(name, teamColor) {\n    this.partners = [];\n    this.enemies = [];\n    this.state = 'alive';\n    this.name = name;\n    this.teamColor = teamColor;//队伍颜色\n  }\n  win() {\n    console.log(this.name + '  win!')\n  }\n  lose() {\n    console.log(this.name + ' lose!')\n  }\n\n  die() {\n    //需要便利自己队友是否全部死完\n    let all_dead = true;\n    this.state = 'dead';\n    for (let i = 0, partner; partner = this.partners[i++];) {\n      if (partner.state !== 'dead') {\n        all_dead = false;\n        break;\n      }\n    }\n    if (all_dead === true) {\n      this.lose();\n      //通知所有队友失败了\n      for (let i = 0, partner; partner = this.partners[i++];) {\n        partner.lose();\n      }\n      // 通知所有敌人游戏胜利\n      for (let i = 0, enemy; enemy = this.enemies[i++];) {\n        enemy.win()\n      }\n    }\n  }\n}\n\n\n// 工厂函数创建玩家并设置关系\nfunction playerFactory(name, teamColor) {\n  const newPlayer = new Player(name, teamColor);\n  for (let i = 0, player; player = players[i++];) {\n    // 有新的角色加入\n    if (player.teamColor === newPlayer.teamColor) {\n      //同一队的,添加队友\n      player.partners.push(newPlayer);\n      newPlayer.partners.push(player)\n    } else {\n      player.enemies.push(newPlayer);\n      newPlayer.enemies.push(player)\n    }\n  }\n  players.push(newPlayer);\n  return newPlayer;\n}\n\nconst player1 = playerFactory('玩家1', 'red')\nconst player2 = playerFactory('玩家2', 'red')\nconst player3 = playerFactory('玩家3', 'red')\nconst player4 = playerFactory('玩家4', 'red')\n\nconst player5 = playerFactory('玩家5', 'blue')\nconst player6 = playerFactory('玩家6', 'blue')\nconst player7 = playerFactory('玩家7', 'blue')\nconst player8 = playerFactory('玩家8', 'blue')\n\nplayer1.die();\nplayer2.die();\nplayer3.die();\nplayer4.die();\n```\n\n我们如果向最开始两人那样手动的去设置关系，那无疑是很麻烦的，所以我们写了一个工厂函数来减少工作量。\n\n#### 中介者模式优化代码\n\n上面的代码虽然看起来还不是很复杂，但是每次死亡等操作都要遍历的通知所有人，如果遇到更多玩家的话那会是很消耗性能的。以下就利用中介者模式进行改造：\n\n```js\n// 所有的玩家\nconst players = [];\n\n// 中介者对象\nclass PlayDirector {\n  constructor() {\n    // 所有玩家\n    this.players = {};\n    // 中介者可执行的操作\n    this.options = {};\n  }\n  addPlayer(player) {\n    const teamColor = player.teamColor;\n    this.players[teamColor] = this.players[teamColor] ?? [];\n    this.players[teamColor].push(player);\n  }\n  remove(player) {\n    const teamColor = player.teamColor;\n    const teamPlayers = this.players[teamColor] ?? [];\n    for (let i = teamPlayers.length - 1; i >= 0; i--) {\n      if (teamPlayers[i] === player) {\n        teamPlayers.splice(i, 1);\n      }\n    }\n  }\n  changeTeam(player, newTeamColor) {\n    console.log(player.name, '逃跑到' + newTeamColor + '成功');\n    this.remove(player);\n    player.teamColor = newTeamColor;\n    this.addPlayer(player);\n  }\n  playerDead(player) {\n    const teamColor = player.teamColor;\n    const teamPlayers = this.players[teamColor];\n    let all_dead = true;\n    for (let i = 0, player; player = teamPlayers[i++];) {\n      // 有一个活的就不算输\n      if (player.state !== 'dead') {\n        all_dead = false;\n        break;\n      }\n    }\n    if (all_dead === true) {\n      for (let i = 0, player; player = teamPlayers[i++];) {\n        player.lose();\n      }\n      //其他队伍玩家赢\n      for (const color in this.players) {\n        if (color !== teamColor) {\n          const teamPlayers = this.players[color];\n          for (let i = 0, player; player = teamPlayers[i++];) {\n            player.win();\n          }\n        }\n      }\n    }\n  }\n// 封装一个函数用于执行内部方法\n  reciveMessage(operationType, ...args) {\n    this[operationType].apply(this, args);\n  }\n}\n\nconst playDirector = new PlayDirector();\n\nclass Player {\n  constructor(name, teamColor) {\n    this.state = 'alive';\n    this.name = name;\n    this.teamColor = teamColor;//队伍颜色\n  }\n  win() {\n    console.log(this.name + '  win!')\n  }\n  lose() {\n    console.log(this.name + ' lose!')\n  }\n\n  die() {\n    this.state = 'dead';\n    // 给中介者发消息，玩家死亡\n    playDirector.reciveMessage('playerDead', this)\n\n  }\n  remove() {\n    // 移除玩家\n    console.log(this.name, '被移除游戏')\n    playDirector.reciveMessage('remove', this)\n  }\n  changeTeam(teamColor) {\n    // 玩家换队\n    playDirector.reciveMessage('changeTeam', this, teamColor)\n  }\n}\n\n\n// 工厂函数创建玩家\nfunction playerFactory(name, teamColor) {\n  const newPlayer = new Player(name, teamColor);\n  // 给中介者发送消息，增加玩家\n  playDirector.addPlayer(newPlayer)\n  return newPlayer;\n}\n\n\n\n\nconst player1 = playerFactory('玩家1', 'red')\nconst player2 = playerFactory('玩家2', 'red')\nconst player3 = playerFactory('玩家3', 'red')\nconst player4 = playerFactory('玩家4', 'red')\n\nconst player5 = playerFactory('玩家5', 'blue')\nconst player6 = playerFactory('玩家6', 'blue')\nconst player7 = playerFactory('玩家7', 'blue')\nconst player8 = playerFactory('玩家8', 'blue')\n\nplayer1.remove();\nplayer2.changeTeam('blue');\nplayer3.die();\nplayer4.die();\n```\n\n#### 购买商品\n\n我们购买商品需要先填写商品的一些参数比如颜色数量，我们选择后再判断库存后才能购买：\n\n```js\n// 获取元素\n\nconst colorSelect = document.getElementById('colorSelect');\nconst numberInput = document.getElementById('numberInput');\nconst colorInfo = document.getElementById('colorInfo');\nconst numberInfo = document.getElementById('numberInfo');\nconst nextBtn = document.getElementById('nextBtn');\n\n// 手机库存\nconst goods = {\n  red: 3,\n  blue: 6\n}\n\ncolorSelect.onchange = function () {\n  const color = this.value;\n  const number = numberInput.value;\n  stock = goods[color];\n  colorInfo.innerHTML = color;\n  if (!color) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择手机颜色';\n    return;\n  }\n  if (!Number.isInteger(number - 0) || number <= 0) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请输入正确的购物数量';\n    return;\n  }\n  if (number > stock) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '库存不足';\n    return;\n  }\n  nextBtn.disabled = false;\n  nextBtn.innerHTML = '放入购物车';\n}\n\nnumberInput.oninput = function () {\n  const color = colorSelect.value;\n  number = this.value;\n  stock = goods[color];\n  numberInfo.innerHTML = number;\n  if (!color) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择手机颜色';\n    return\n  }\n  if (!Number.isInteger(number - 0) || number <= 0) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请输入正确的购物数量';\n    return;\n  }\n  if (number > stock) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '库存不足';\n    return;\n  }\n  nextBtn.disabled = false;\n  nextBtn.innerHTML = '放入购物车';\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <select id=\"colorSelect\">\n    <option value=\"\">请选择</option>\n    <option value=\"red\">红色</option>\n    <option value=\"blue\">蓝色</option>\n  </select>\n  输入购买数量：\n  <input type=\"text\" id=\"numberInput\">\n  <br>\n  <hr>\n  您选择的颜色：\n  <div id=\"colorInfo\">\n\n  </div>\n  您输入的数量：\n  <div id=\"numberInfo\">\n\n  </div>\n  <hr>\n  <hr>\n  <button id=\"nextBtn\" disabled>请选择手机颜色和数量</button>\n  <script src=\"./4-购物选择模块.js\"></script>\n</body>\n\n</html>\n```\n\n当我们选择或者输入的时候都会区判断这些逻辑，这看起来十分的臃肿。如果我们后续又添加了一个参数，比如手机的内存选择，这又需要改动内部的代码：\n\n```js\n// 获取元素\n\nconst colorSelect = document.getElementById('colorSelect');\nconst numberInput = document.getElementById('numberInput');\nconst memorySelect = document.getElementById('memorySelect');\nconst colorInfo = document.getElementById('colorInfo');\nconst numberInfo = document.getElementById('numberInfo');\nconst memoryInfo = document.getElementById('memoryInfo');\nconst nextBtn = document.getElementById('nextBtn');\n\n// 手机库存\nconst goods = {\n  'red|32G': 3,\n  \"red|16G\": 0,\n  'blue|32G': 1,\n  \"blue|16G\": 6,\n\n}\n\ncolorSelect.onchange = function () {\n  const color = colorSelect.value;\n  const number = numberInput.value;\n  const memory = memorySelect.value;\n  stock = goods[color + '|' + memory];\n  colorInfo.innerHTML = color;\n  if (!color) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择手机颜色';\n    return;\n  }\n  if (!memory) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择内存';\n    return;\n  }\n  if (!Number.isInteger(number - 0) || number <= 0) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请输入正确的购物数量';\n    return;\n  }\n  if (number > stock) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '库存不足';\n    return;\n  }\n  nextBtn.disabled = false;\n  nextBtn.innerHTML = '放入购物车';\n}\n\nnumberInput.oninput = function () {\n  const color = colorSelect.value;\n  const number = numberInput.value;\n  const memory = memorySelect.value;\n  const stock = goods[color + '|' + memory];\n  numberInfo.innerHTML = number;\n  if (!color) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择手机颜色';\n    return\n  }\n  if (!memory) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择内存';\n    return;\n  }\n  if (!Number.isInteger(number - 0) || number <= 0) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请输入正确的购物数量';\n    return;\n  }\n  if (number > stock) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '库存不足';\n    return;\n  }\n  nextBtn.disabled = false;\n  nextBtn.innerHTML = '放入购物车';\n}\n\n\nmemorySelect.onchange = function () {\n  const color = colorSelect.value;\n  const number = numberInput.value;\n  const memory = memorySelect.value;\n  stock = goods[color + '|' + memory];\n  numberInfo.innerHTML = number;\n  if (!color) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择手机颜色';\n    return\n  }\n  if (!memory) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请选择内存';\n    return;\n  }\n  if (!Number.isInteger(number - 0) || number <= 0) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '请输入正确的购物数量';\n    return;\n  }\n  console.log(stock);\n  if (number > stock) {\n    nextBtn.disabled = true;\n    nextBtn.innerHTML = '库存不足';\n    return;\n  }\n  nextBtn.disabled = false;\n  nextBtn.innerHTML = '放入购物车';\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  颜色：\n  <select id=\"colorSelect\">\n    <option value=\"\">请选择</option>\n    <option value=\"red\">红色</option>\n    <option value=\"blue\">蓝色</option>\n  </select>\n  内存：\n  <select id=\"memorySelect\">\n    <option value=\"\">请选择</option>\n    <option value=\"32G\">32G</option>\n    <option value=\"16G\">16G</option>\n  </select>\n  输入购买数量：\n  <input type=\"text\" id=\"numberInput\">\n  <br>\n  <hr>\n  您选择的颜色：\n  <div id=\"colorInfo\">\n\n  </div>\n  您选择的内存：\n  <div id=\"memoryInfo\">\n\n  </div>\n  您输入的数量：\n  <div id=\"numberInfo\">\n\n  </div>\n  <hr>\n  <hr>\n  <button id=\"nextBtn\" disabled>请选择手机颜色和数量</button>\n  <!-- <script src=\"./5-购物车改动.js\"></script> -->\n  <script src=\"./6-引入中介者模式解决购物车问题.js\"></script>\n</body>\n\n</html>\n```\n\n可以看到我们加了一个条件后就多了这么多代码。\n\n#### 中介者模式改造代码\n\n我们可以将上述公共代码放到中介者对象中进行复用：\n\n```js\n// 获取元素\n\n\n// 手机库存\nconst goods = {\n  'red|32G': 3,\n  \"red|16G\": 0,\n  'blue|32G': 1,\n  \"blue|16G\": 6,\n\n}\n\nclass Mediator {\n  constructor() {\n    this.colorSelect = document.getElementById('colorSelect');\n    this.numberInput = document.getElementById('numberInput');\n    this.memorySelect = document.getElementById('memorySelect');\n    this.colorInfo = document.getElementById('colorInfo');\n    this.numberInfo = document.getElementById('numberInfo');\n    this.memoryInfo = document.getElementById('memoryInfo');\n    this.nextBtn = document.getElementById('nextBtn');\n  }\n  changed(obj) {\n    const color = this.colorSelect.value;\n    const number = this.numberInput.value;\n    const memory = this.memorySelect.value;\n    const stock = goods[color + '|' + memory];\n    if (obj === this.olorSelect) {\n      this.colorInfo.innerHTML = color;\n    } else if (obj === this.memorySelect) {\n      console.log(memory);\n      this.memoryInfo.innerHTML = memory;\n    } else if (obj === this.numberInput) {\n      this.numberInfo.innerHTML = number;\n    }\n    if (!color) {\n      nextBtn.disabled = true;\n      nextBtn.innerHTML = '请选择手机颜色';\n      return;\n    }\n    if (!memory) {\n      nextBtn.disabled = true;\n      nextBtn.innerHTML = '请选择内存';\n      return;\n    }\n    if (!Number.isInteger(number - 0) || number <= 0) {\n      nextBtn.disabled = true;\n      nextBtn.innerHTML = '请输入正确的购物数量';\n      return;\n    }\n    if (parseInt(number) > stock) {\n      nextBtn.disabled = true;\n      nextBtn.innerHTML = '库存不足';\n      return;\n    }\n    nextBtn.disabled = false;\n    nextBtn.innerHTML = '放入购物车';\n  }\n}\n\nconst mediator = new Mediator();\n\ncolorSelect.onchange = function () {\n  mediator.changed(this)\n}\n\nnumberInput.oninput = function () {\n  mediator.changed(this)\n}\n\n\nmemorySelect.onchange = function () {\n  mediator.changed(this)\n}\n```\n\n#### 总结\n\n中介者模式是符合最少知识原则，使得对象之间的关系不在过于耦合，但是也有一定的确定啊就是会使得系统中多一个中介者对象。\n\n在实际项目中，模块或对象之间有一些依赖关系是很正常的。如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。\n\n### 装饰器模式\n\n含义：给对象动态地增加职责。\n\n#### 传统语言的装饰器\n\n```js\nclass Plane {\n  fire() {\n    console.log('发射普通子弹')\n  }\n}\n\nclass MissileDecorator {\n  constructor(plane) {\n    this.plane = plane;\n  }\n  fire() {\n    this.plane.fire();\n    console.log('发射导弹')\n  }\n}\n\nclass AtomDecorator {\n  constructor(plane) {\n    this.plane = plane;\n  }\n  fire() {\n    this.plane.fire();\n    console.log('发射原子弹')\n  }\n}\n\nlet plane = new Plane();\n\nplane = new MissileDecorator(plane);\nplane.fire();\nplane = new AtomDecorator(plane);\nplane.fire();\n```\n\n#### JavaScript实现装饰器\n\n对于JS来说实现装饰器是非常容易的，且并不需要类来实现：\n\n```js\nconst plane = {\n  fire() {\n    console.log('发射普通子弹')\n  }\n}\n\nconst missileDecorator = function () {\n  console.log('发射导弹')\n}\n\nconst atomDecorator = function () {\n  console.log('发射原子弹')\n}\n\nlet fire1 = plane.fire;\n\nplane.fire = function () {\n  fire1();\n  missileDecorator();\n}\nplane.fire();\n\nlet fire2 = plane.fire;\nplane.fire = function () {\n  fire2();\n  atomDecorator();\n}\n\nplane.fire();\n```\n\n#### AOP实现装饰器\n\n上面我们通过重写函数来达到装饰器的功能，这是违反开放封闭原则的，所以我们可以借助原型链来进一步改造：\n\n```js\nFunction.prototype.before = function (beforeFn) {\n  const __self = this;\n  return function (...args) {\n    beforeFn.apply(this, args);\n    return __self.apply(this, args)\n  }\n}\n\n\nFunction.prototype.after = function (afterFn) {\n  const __self = this;\n  return function (...args) {\n    const ret = __self.apply(this, args);\n    afterFn.apply(this, args);\n    return ret;\n  }\n}\n\n// document.getElementById = document.getElementById.before(function () {\n//   alert(1);\n// })\n\nconst button = document.getElementById('button');\nconsole.log(button)\n\nwindow.onload = function () {\n  alert(1);\n}\n\nwindow.onload = (window.onload || function () { }).after(function () {\n  alert(2);\n}).after(function () {\n  alert(3)\n}).after(function () {\n  alert(4)\n})\n```\n\n当然如果你不喜欢再原型链上加一些函数你可以使用以下方案：\n\n```js\nfunction after(fn, afterFn) {\n  return function (...args) {\n    const ret = fn.apply(this, args);\n    afterFn.apply(this, args);\n    return ret;\n  }\n}\n\nfunction before(fn, beforeFn) {\n  return function (...args) {\n    // 这里共用一个属性对象所以可以修改args动态给原函数扩展参数\n    beforeFn.apply(this, args);\n    return fn.apply(this, args);\n  }\n}\n\n// document.getElementById = document.getElementById.before(function () {\n//   alert(1);\n// })\n\nconst button = document.getElementById('button');\nconsole.log(button)\n\nwindow.onload = function (params) {\n  //alert(1);\n  console.log(params);\n}\n\nwindow.onload = before((window.onload || function (params) { }), function (params) {\n  params.a = 11111;\n})\n```\n\n#### 总结\n\n装饰器模式使用实例也非常广泛，其中AOP的装饰器技巧在实际的开发中非常有用，比如我们可以进行数据上报，在某些操作后上报数据，再比如动态修改函数的参数（参数是个对象）。\n\n![image.png](https://topzhang.cn/usr/uploads/2022/05/3451201245.png)\n\n### 状态模式\n\n#### 电灯程序\n\n```js\nclass Light {\n  constructor() {\n    this.state = 'off';\n    this.button = null;\n  }\n  init() {\n    const button = document.createElement('button');\n    button.innerHTML = '开关';\n    this.button = document.body.appendChild(button);\n    this.button.onclick = () => {\n      this.buttonWasPress();\n    }\n  }\n  buttonWasPress() {\n    if (this.state === 'off') {\n      console.log('开灯');\n      this.state = 'on';\n    } else if (this.state === 'on') {\n      console.log('关灯');\n      this.state = 'off';\n    }\n  }\n}\n\nconst light = new Light();\nlight.init();\n```\n\n上述代码能完美的实现功能，但是切换状态的函数内部存在比较死板的条件判断。如果我们不止两种状态的话又会去堆砌条件判断语句。\n\n#### 状态模式改进\n\n```js\nclass Light {\n  constructor() {\n    this.offLightState = new OffLightState(this);\n    this.weakLightState = new WeakLightState(this);\n    this.strongLightState = new StrongLightState(this);\n    this.superStrongLightState = new SuperStrongLightState(this);\n    this.button = null;\n  }\n  init() {\n    const button = document.createElement('button');\n    button.innerHTML = '开关';\n    this.button = document.body.appendChild(button);\n    this.currentState = this.offLightState;\n    this.button.onclick = () => {\n      this.currentState.buttonWasPressed();\n    }\n  }\n  setState(newState) {\n    this.currentState = newState\n  }\n}\n\nclass OffLightState {\n  constructor(light) {\n    this.light = light\n  }\n  buttonWasPressed() {\n    console.log('弱光');\n    this.light.setState(this.light.weakLightState);\n  }\n}\n\nclass WeakLightState {\n  constructor(light) {\n    this.light = light\n  }\n  buttonWasPressed() {\n    console.log('强光');\n    this.light.setState(this.light.strongLightState);\n  }\n}\n\n\nclass StrongLightState {\n  constructor(light) {\n    this.light = light\n  }\n  buttonWasPressed() {\n    console.log('超强光');\n    this.light.setState(this.light.superStrongLightState);\n  }\n}\n\nclass SuperStrongLightState {\n  constructor(light) {\n    this.light = light\n  }\n  buttonWasPressed() {\n    console.log('关灯');\n    this.light.setState(this.light.offLightState);\n  }\n}\n\nconst light = new Light();\nlight.init();\n```\n\n我们把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句。\n\n#### JS版状态机\n\n```js\nfunction delegate(client, delegation) {\n  return {\n    buttonWasPressed(...args) {\n      return delegation.buttonWasPressed.apply(client, args)\n    }\n  }\n}\n\nconst FSM = {\n  offLightState: {\n    buttonWasPressed() {\n      console.log('关灯');\n      this.currentState = this.onLightState;\n    }\n  },\n  onLightState: {\n    buttonWasPressed() {\n      console.log('开灯');\n      this.currentState = this.offLightState;\n    }\n  }\n}\n\nclass Light {\n  constructor() {\n    this.offLightState = delegate(this, FSM.offLightState);\n    this.onLightState = delegate(this, FSM.onLightState);\n    this.currentState = this.offLightState;\n    this.button = null;\n  }\n  init() {\n    const button = document.createElement('button');\n    button.innerHTML = '开关';\n    this.button = document.body.appendChild(button);\n    this.button.onclick = () => {\n      this.currentState.buttonWasPressed();\n    }\n  }\n  setState(newState) {\n    this.currentState = newState\n  }\n}\n\nconst light = new Light();\nlight.init();\n```\n\n还有一种表驱动的状态机，详见[javascript-state-machine](https://github.com/jakesgordon/javascript-state-machine)\n\n#### 总结\n\n状态模式优点如下：\n\n- 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。\n- 避免Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支。\n- 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。\n- Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。\n\n参考文献：\n\n[发布订阅模式，在工作中它的能量超乎你的想象](https://juejin.cn/post/6844903616172539917)\n\n[JavaScript设计模式与开发实践](https://weread.qq.com/web/reader/6bf3215071a123016bf0b74kc81322c012c81e728d9d180)\n\n\n",
      "type": 1,
      "id": 3
    },
    {
      "title": "11122",
      "context": "# TypeScript 语法总结\n\n## 数据类型\n\n### number\n\n`TS`和`JS`一样不区分整型和浮点型，统一称为`number`类型。\n\n```typescript\nlet age: number = 18;\nconst height: number = 1.88;\n```\n\n默认情况下，会将赋值的值的类型，作为前面标识符的类型，这个过程称之为类型推导。\n\n```typescript\nlet a = 100; //a就是number类型了\na = \"hello\"; //会报错\n```\n\n### boolean\n\n两个值 `true`和 `false。`\n\n```typescript\nlet flag: boolean = true;\nflag = 20 > 30;\n```\n\n### string\n\n字符串类型，支持单双或引号表示，也支持模板字符串。\n\n```typescript\nlet message1: string = \"hello world\";\nlet message2: string = \"Hello World\";\n\n// 个人习惯: 默认情况下, 如果可以推导出对应的标识符的类型时, 一般情况下是不加\nconst name = \"why\";\nconst age = 18;\nconst height = 1.88;\n\nlet message3 = `name:${name} age:${age} height:${height}`;\nconsole.log(message3);\n```\n\n### array\n\n在 JS 中我们数组中可以存放任意的类型，但这是不太好的一种表现，因为不同类型的数据就不好统一的做处理，所以`TS`可以创建存放相同类型数据的数组。\n\n```typescript\n//创建方式1\nconst arr1: Array<string> = [];\narr1.push(123); //报错\n```\n\n上述方式可以创建只能存放`string`类型的数组，但是上述方式的写法在`jsx`语法中是有冲突的，和标签语法冲突，所以不推荐。\n\n```jsx\n//创建方式2\nconst arr2: string[] = [];\n```\n\n### object，Object 和{}\n\n#### object 类型用于表示非原始类型\n\n```typescript\nconst info = {\n  name: \"why\",\n  age: 18,\n};\n//通过下面的这种方式创建的对象不能取值和设置值\nconst obj: object = {\n  name: \"zhangsan\",\n};\n\nlet objectCase: object;\nobjectCase = 1; // error\nobjectCase = \"a\"; // error\nobjectCase = true; // error\nobjectCase = null; // error\nobjectCase = undefined; // error\nobjectCase = {}; // ok\n\nconsole.log(info.name);\nconsole.log(obj.name); //报错\n```\n\n#### Object\n\n这里注意大写的`Object`代表拥有一些方法类型如`toString()`，`hasOwnProperty`。所以所有原始类型、非原始类型都可以赋给 `Object`(严格模式下 `null` 和 `undefined` 不可以)。\n\n```javascript\nlet ObjectCase: Object;\nObjectCase = 1; // ok\nObjectCase = \"a\"; // ok\nObjectCase = true; // ok\nObjectCase = null; // error\nObjectCase = undefined; // error\nObjectCase = {}; // ok\n```\n\n`{}`和`Object`一样。\n\n### symbol\n\n这里介绍基本使用方式，在对象中不能设置两个属性相同的属性。我们在使用 `Symbol` 的时候，必须添加 `es6` 的编译辅助库 需要在 tsconfig.json 的 `libs` 字段加上`ES2015` `Symbol` 的值是唯一不变的。\n\n```typescript\nconst info1 = {\n  title: \"zhangsan\",\n  title: \"lisi\", //上面的就会被覆盖掉\n};\n//这样就可以了\nconst info2 = {\n  title1: \"zhangsan\",\n  title2: \"lisi\",\n};\n//使用symbol类型\nconst title1: symbol = Symbol(\"title\");\nconst title2 = Symbol(\"title\");\nconst info3 = {\n  [title1]: \"zhangsan\",\n  [title2]: \"lisi\",\n};\n```\n\n### null 和 undefined\n\n`null`类型只有一个值`null`，`undefined`也只有一个值`undefined`\n\n```typescript\nlet n1: null = null;\nlet n2 = null; //这里n2为 any 类型\n\nlet n3: undefined = undefined;\nlet n4 = undefined; //这里n4为 any 类型\n```\n\n### any\n\n有时我们无法确定一个变量的类型，并且它有可能变化，我们就可以使用`any`类型。我们可以对`any`类型进行任意的操作，对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用`any`。当然也不要过渡依赖这个类型，不然你使用`ts`就毫无意义了。\n\n```typescript\nlet a: any = \"why\";\na = 123;\na = true;\nconst arr: any[] = [12, \"zhang\"];\n```\n\n### unknow\n\n用于描述不确定的类型，其他的类型都可以赋值给`unknow`类型，但是`unkonw`只能赋值给`any`和`unkonw`类型。\n\n```javascript\nfunction foo() {\n  return \"abc\";\n}\nfunction bar() {\n  return 123;\n}\n// unknown类型只能赋值给any和unknown类型\n// any类型可以赋值给任意类型\nlet flag = true;\nlet result: unknown; // 最好不要使用any\nif (flag) {\n  result = foo();\n} else {\n  result = bar();\n}\n\nlet message: string = result; //报错\nlet num: number = result; //报错\n\nconsole.log(result);\n```\n\n### void\n\n`void`一般表示一个函数是没有返回值的，那么它的返回值就是`void`类型，`JS`中函数默认的返回值是`undefined`，`TS`中默认是`void`类型。\n\n可以将`null`和`undefined`类型赋值给`void`类型。\n\n```typescript\nfunction sum(num1: number, num2: number) {\n  console.log(num1 + num2);\n}\nfunction sum1(num1: number, num2: number): void {\n  console.log(num1 + num2);\n}\n\nsum(20, 30);\n```\n\n### never\n\n`never`类型表示永远也不会发生的类型。\n一个函数中有死循环或者抛出异常，该函数是不会返回任何东西的，所以`void`类型是不适合的，我们可以使用`never`类型。\n\n```typescript\nfunction foo(): never {\n  // 死循环\n  while (true) {}\n}\nfunction bar(): never {\n  throw new Error();\n}\n```\n\n另外还有一个场景\n\n```typescript\nfunction handleMessage(message: string | number | boolean) {\n  switch (typeof message) {\n    case \"string\":\n      console.log(\"string处理方式处理message\");\n      break;\n    case \"number\":\n      console.log(\"number处理方式处理message\");\n      break;\n    default:\n      const check: never = message;\n  }\n}\n```\n\n如果我们封装一个函数，我们对参数类型的判断处理不全面，可以设置一个默认处理方式，当我们漏掉对某种数据类型判断处理的时候就可以将其赋值给`never`类型，当然这绝对会报错的，这时我们就能发现我们对该数据类型漏处理，从而补全逻辑。\n\n### tuple\n\n元组类型\n\n通常数组中会存放数据类型相同的元素，要存放不同类型的元素建议使用对象或者元组数组。\n\n元组中每个元素都有自己的特性，根据索引值获取到的值可以确定对应的类型。\n\n```typescript\nconst info: [string, number, number] = [\"why\", 18, 1.88];\nconst name = info[0]; //一定为string类型\nconsole.log(name.length);\n```\n\n应用场景：\n\n```typescript\nfunction useState<T>(state: T) {\n  let currentState = state;\n  const changeState = (newState: T) => {\n    currentState = newState;\n  };\n  const info: [string, number] = [\"abc\", 18];\n  const tuple: [T, (newState: T) => void] = [currentState, changeState];\n  return tuple;\n}\n\nconst [counter, setCounter] = useState(10);\nsetCounter(1000);\nconst [title, setTitle] = useState(\"abc\"); //每个返回的数据类型的都是确定的\nconst [flag, setFlag] = useState(true);\n```\n\n### 枚举类型\n\n枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型。枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型。\n\n```typescript\nenum Direction {\n  LEFT,\n  RIGHT,\n  TOP,\n  BOTTON,\n}\nfunction turnDirection(direction: Direction) {\n  switch (direction) {\n    case Direction.LEFT:\n      console.log(\"向左\");\n      break;\n    case Direction.RIGHT:\n      console.log(\"向右\");\n      break;\n    case Direction.TOP:\n      console.log(\"向上\");\n      break;\n    case Direction.BOTTON:\n      console.log(\"向下\");\n      break;\n    default:\n      console.log(\"没有\");\n  }\n}\n\nturnDirection(Direction.LEFT);\nturnDirection(Direction.RIGHT);\nturnDirection(Direction.TOP);\nturnDirection(Direction.BOTTON);\n```\n\n#### 枚举类型的值\n\n枚举类型默认值是从 0 开始依次递增的，也可以给枚举设置初始值。\n\n```typescript\nenum Direction {\n  LEFT = 100,\n  RIGHT,\n  TOP,\n  BOTTON,\n}\n//输出的值就是从100开始 +1 递增\n```\n\n## 函数\n\n### 函数定义\n\n**函数声明**\n\n```js\nfunction hello(name: string) {\n  console.log(name);\n}\nhello(\"world\");\n```\n\n**函数表达式**\n\n```js\ntype SumFunc = (x: number, y: number) => number;\nconst sumFunc: SumFunc = (a, b) => {\n  return a + b;\n};\n```\n\n### 函数参数\n\n我们定义函数的时候可以给函数参数设置类型注释，当然也可以不设置（自动推导）\n\n```typescript\nfunction sum(num1: number, num2: number) {\n  return num1 + num2;\n}\nsum(123, 321);\n```\n\n#### 匿名函数的参数类型\n\n有时候我们的函数参数是一个函数，那么这个函数的参数值就是根据上下文环境推断出来的。\n\n```typescript\nconst names = [\"abc\", \"cba\", \"nba\"];\n// item根据上下文的环境推导出来的(这里就是string类型), 这个时候可以不添加的类型注解\n// 上下文中的函数: 可以不添加类型注解\nnames.forEach(function (item) {\n  console.log(item.split(\"\"));\n});\n```\n\n#### 函数参数的对象类型\n\n参数为对象的函数，我们还可以详细的设置对象中的属性的数据类型\n\n```typescript\nfunction printPoint(point: { x: number; y: number }) {\n  console.log(point.x);\n  console.log(point.y);\n}\nprintPoint({ x: 123, y: 321 });\n```\n\n#### 函数默认参数\n\n```js\nfunction sum100(x: number, y: number = 100) {\n  return x + y;\n}\n\nconsole.log(sum100(12)); //112\n```\n\n##### 剩余参数\n\n函数剩余参数：剩余参数语法允许我们将一个不定数量的参数放到一个数组中。\n\n```js\nfunction sumarg(...arg: number[]) {\n  return arg;\n}\n\nconsole.log(sumarg(1, 2, 3, 4, 5));\n```\n\n### 函数类型\n\n函数作为参数的时候也要确定类型的 。\n\n```typescript\nfunction foo() {}\ntype FooFnType = () => void;\nfunction bar(fn: FooFnType) {\n  fn();\n}\nbar(foo);\n```\n\n上面的语法 `() => void` 就是一个函数类型 没有参数，且没有返回值。\n\n```typescript\ntype AddFnType = (num1: number, num2: number) => number;\n//使用函数表达式方式创建函数\nconst add: AddFnType = (a1: number, a2: number) => {\n  return a1 + a2;\n};\n```\n\n### 函数中的 this\n\n`this`也是一个对象，当然它也有类型，`TS`可以默认被推导出来。\n\n```typescript\nconst info = {\n  name: \"why\",\n  eating() {\n    //这里推导出来就是info对象\n    console.log(this.name + \" eating\");\n  },\n};\ninfo.eating();\n```\n\n有些情况 TS 就推导不出来，导致报错。\n\n```typescript\nfunction eating() {\n  console.log(this.name + \" eating\", message);\n}\nconst info = {\n  name: \"why\",\n  eating: eating,\n};\n// 隐式绑定\ninfo.eating(); //编译报错\n```\n\n上述代码就会编译报错，解决方式如下：\n\n```typescript\ntype ThisType = { name: string }; //自定义一个this类型\n\nfunction eating(this: ThisType) {\n  console.log(this.name + \" eating\");\n}\n\nconst info = {\n  name: \"why\",\n  eating: eating,\n};\n\n// 隐式绑定\ninfo.eating();\n```\n\n### 函数的重载\n\n有时候我们通过联合类型会进行很多的逻辑判断，导致代码太冗长，而且返回值有可能也不确定。\n\n```typescript\nfunction add(a1: number | string, a2: number | string) {\n  if (typeof a1 === \"number\" && typeof a2 === \"number\") {\n    return a1 + a2;\n  } else if (typeof a1 === \"string\" && typeof a2 === \"string\") {\n    return a1 + a2;\n  }\n}\n\nadd(10, 20);\n```\n\n对于上述案例我们可以采用函数的重载来简化代码书写：\n\n函数的名称相同， 但是参数不同的几个函数， 就是函数的重载。\n\n定义函数重载的函数是没有函数体，另外还需要一个参数数量相同但是能接受`any`类型有函数体的函数。有点抽象，基本语法如下：\n\n```typescript\nfunction add(num1: number, num2: number): number;\nfunction add(num1: string, num2: string): string;\nfunction add(num1: any, num2: any): any {\n  if (typeof num1 === \"string\" && typeof num2 === \"string\") {\n    return num1.length + num2.length;\n  }\n  return num1 + num2;\n}\n```\n\n```typescript\nconst result = add(20, 30); //50\nconst result2 = add(\"abc\", \"cba\"); //6\nconsole.log(result);\nconsole.log(result2);\n```\n\n注意:函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型\n\n## 可选类型\n\n对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个`?`\n\n```typescript\nfunction printPoint(point: { x: number; y: number; z?: number }) {\n  console.log(point.x);\n  console.log(point.y);\n  console.log(point.z);\n}\n//可以传2个或者3个参数\nprintPoint({ x: 123, y: 321 });\nprintPoint({ x: 123, y: 321, z: 111 });\n```\n\n## 联合类型\n\n我们可以指定一个参数为多种类型\n\n```typescript\nfunction printID(id: number | string | boolean) {\n  // 使用联合类型的值时, 需要特别的小心\n  if (typeof id === \"string\") {\n    //这里就可以判断出id是否为string类型了\n    // TypeScript帮助确定id一定是string类型\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}\n\nprintID(123);\nprintID(\"abc\");\nprintID(true);\n```\n\n当一个函数的参数只有一个，而且设置成可选，那么也相当于该参数为联合类型,，另外函数的可选参数只能放在最后。\n\n```typescript\nfunction foo(message?: string) {\n  console.log(message);\n}\n//等同于\nfunction foo(message: string | undefined) {\n  console.log(message);\n}\nfoo();\n```\n\n## 类型别名\n\n参数的类型注释过于冗长的时候可以设置一个别名来代替这种注释\n\n```typescript\ntype IDType = string | number | boolean;\ntype PointType = {\n  x: number;\n  y: number;\n  z?: number;\n};\nfunction printId(id: IDType) {}\nfunction printPoint(point: PointType);\n```\n\n## 类型断言\n\n有时候我们获取到到的类型信息不是具体的，比如我们通过`document.getElementById`获取到类型是一个`HTMLElement`，但是并不知道具体的类型：\n\n```typescript\nconst el = document.getElementById(\"why\") as HTMLImageElement;\nel.src = \"zxxx\";\n```\n\n另外我们也可以利用类型断言为更具体或者不太具体的类型版本\n\n```typescript\nconst name = \"code\" as number; //报错\nconst name2 = \"code\" as unknow as number; //可以\n```\n\n## 非空类型断言\n\n有时候我们会执行一个对象的方法，但是该对象有可能为`undefined`，那么我们执行就会报错。\n\n```typescript\nfunction printMessage(message?: string) {\n  console.log(message.length); //有可能message为undefined,从而报错\n  console.log(message!.length); //保证不为空。不会报错\n}\n```\n\n使用 `!.` 表示可以确定某个标识符是有值，跳过`ts`在编译阶段对它的检测。\n\n## 类型保护\n\n### typeof 类型保护\n\n```javascript\nfunction double(input: string | number | boolean) {\n  if (typeof input === \"string\") {\n    return input + input;\n  } else {\n    if (typeof input === \"number\") {\n      return input * 2;\n    } else {\n      return !input;\n    }\n  }\n}\n```\n\n### in 关键字\n\nin 关键字是判断对象上是否有该属性。\n\n```typescript\ninterface Bird {\n  fly: number;\n}\n\ninterface Dog {\n  leg: number;\n}\n\nfunction getNumber(value: Dog | Bird) {\n  if (\"fly\" in value) {\n    return value.fly;\n  }\n  return value.leg;\n}\n```\n\n### instanceof 类型保护\n\ninstanceof 是判断属性是否在对象的原型链上。\n\n```typescript\nclass Animal {\n  name!: string;\n}\nclass Bird extends Animal {\n  fly!: number;\n}\nfunction getName(animal: Animal) {\n  if (animal instanceof Bird) {\n    console.log(animal.fly);\n  } else {\n    console.log(animal.name);\n  }\n}\n```\n\n#### 自定义类型保护\n\n下面的例子如果函数返回`true`那么定义的`test`就是`string`类型。\n\n```typescript\nfunction isString(test: any): test is string {\n  return typeof test === \"string\";\n}\n\nfunction example(foo: any) {\n  if (isString(foo)) {\n    //此时就缩小确定了foo的类型为string\n    console.log(\"it is a string\" + foo);\n    console.log(foo.length); // string function\n    // 如下代码编译时会出错，运行时也会出错，因为 foo 是 string 不存在toExponential方法\n    //toExponential()为number上的方法，表示以指数表示法返回该数值字符串表示形式\n    console.log(foo.toExponential(2));\n  }\n  // 编译不会出错，但是运行时出错\n  console.log(foo.toExponential(2));\n}\nexample(\"hello world\");\n```\n\n## 可选链\n\n可选链的操作符为 `?.` 当前面的标识符值不存在的时候就会短路返回`undefined`，从而不会报错\n\n```typescript\ntype Person = {\n  name: string;\n  friend?: {\n    name: string;\n    age?: number;\n    girlFriend?: {\n      name: string;\n    };\n  };\n};\nconst info: Person = {\n  name: \"why\",\n};\n\nconsole.log(info.name); //why\nconsole.log(info.friend?.name); //undefined\nconsole.log(info.friend?.age); //undeined\nconsole.log(info.friend?.girlFriend?.name); //undeined\n```\n\n这里再说一个操作符`??` 该操作符为空值操作符，当操作符的左侧为`null`或者`undefined`时，返回右侧的操作数，否则返回左侧操作数。这个与 `||`操作符类似，但是 `||`操作符是当左侧布尔值为`false`时返回右侧的操作数。\n\n```typescript\nlet message: string | null = \"Hello World\";\nconst content = message ?? \"你好啊, 李银河\";\nconsole.log(content); // Hello World\n```\n\n## 字面量类型\n\n我们可以如下定义：\n\n```typescript\nconst message: \"Hello World\" = \"Hello World\";\n```\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210731212853133.png#id=dfZyl&originHeight=59&originWidth=388&originalType=binary&ratio=1&status=done&style=none)\n\n这里显示的类型为 `Hello World` ，这就是字面量类型。当然默认这样做是没有意义的。\n我们可以将多个字面量类型联合起来使用：\n\n```typescript\ntype Alignment = \"left\" | \"right\" | \"center\";\nlet align: Alignment = \"left\";\nalign = \"right\";\nalign = \"center\";\nalign = \"other\"; //报错，只能赋值 'left' | 'right' | 'center'中的一个\n```\n\n## 字面量推理\n\n有如下代码：\n\n```typescript\ntype Method = \"GET\" | \"POST\";\ntype Request = {\n  url: string;\n  method: Method;\n};\n\nconst options = {\n  url: \"https://www.coderwhy.org/abc\",\n  method: \"POST\",\n};\nrequest(options.url, options.method); //这里会报第二个参数的错\n```\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210731213428136.png#id=j9hkD&originHeight=102&originWidth=601&originalType=binary&ratio=1&status=done&style=none)\n\n因为这样传递参数会默认推理为`string`类型，但是我们第二个参数类型为 `Method`字面量。\n两种解决方式：\n\n```typescript\n//第一种\nrequest(options.url, options.method as Method); //将string转为 \"范围更小 \"的字符串字面量\n```\n\n```typescript\nconst options = {\n  url: \"https://www.coderwhy.org/abc\",\n  method: \"POST\",\n} as const; //将对象中的属性 断言为为对应值的字面量类型\n```\n\n## 类\n\n通过`class`关键字来声明\n\n我们可以声明一些类的属性，默认时`any`类型，也可以设置默认值。\n\n类也可以有自己的构造函数，构造函数默认返回当前创造出来的实例。\n\n```typescript\nclass Person {\n  name!: string; //这里加！表示这个属性在实例化的时候可以不用赋值\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  eating() {\n    console.log(this.name + \" eating\");\n  }\n}\nconst p = new Person(\"why\", 18);\nconsole.log(p.name);\nconsole.log(p.age);\np.eating();\n```\n\n我们也可以将属性定义直接写在构造函数中的参数中（当然这样就是不太清晰）。\n\n```js\nclass Person {\n  constructor(public name:string) {\n    this.name = name\n  }\n  getName():void {\n    console.log(this.name)\n  }\n}\n\nconst p = new Person('zhangsan');\np.getName()\n```\n\n### 类的继承\n\n面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。使用`extends`关键字来实现继承，子类中使用`super`来访问父类。\n\n```typescript\nclass Person {\n  name: string;\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n  eating() {\n    console.log(\"eating 100行\");\n  }\n}\n\nclass Student extends Person {\n  sno: number;\n  constructor(name: string, age: number, sno: number) {\n    // super调用父类的构造器\n    super(name, age);\n    this.sno = sno;\n  }\n  eating() {\n    console.log(\"student eating\");\n    super.eating(); //调用父类原型上的方法\n  }\n  studying() {\n    console.log(\"studying\");\n  }\n}\n\nconst stu = new Student(\"why\", 18, 111);\nconsole.log(stu.name);\nconsole.log(stu.age);\nconsole.log(stu.sno);\n\nstu.eating();\n```\n\n### 类的多态\n\n为了写出更加具备通用性的代码。\n\n```typescript\nclass Animal {\n  action() {\n    console.log(\"animal action\");\n  }\n}\n\nclass Dog extends Animal {\n  action() {\n    console.log(\"dog running!!!\");\n  }\n}\n\nclass Fish extends Animal {\n  action() {\n    console.log(\"fish swimming\");\n  }\n}\n\nclass Person extends Animal {}\n\nfunction makeActions(animals: Animal[]) {\n  animals.forEach((animal) => {\n    animal.action();\n  });\n}\nmakeActions([new Dog(), new Fish(), new Person()]);\n```\n\n### 类修饰符\n\n- `public` 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是`public`的\n- `private` 修饰的是仅在同一类中可见、私有的属性或方法,也可以使用#来表示该属性为一个私有属性。 比如，#name:string\n- `protected`修饰的是仅在类自身及子类中可见、受保护的属性或方法\n- `readonly`有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用。\n- `static` 静态成员，只有类本身可以访问\n\n### getter 和 setter\n\n一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(`getter`)和设置(`setter`)的过程。\n\n```typescript\nclass Person {\n  private _name: string;\n  constructor(name: string) {\n    this._name = name;\n  }\n  // 访问器setter/getter\n  // setter\n  set name(newName) {\n    this._name = newName;\n  }\n  // getter\n  get name() {\n    return this._name;\n  }\n}\n\nconst p = new Person(\"why\");\np.name = \"coderwhy\";\nconsole.log(p.name);\n```\n\n上述代码转换为 es5 就就是使用了`Object.defineProperty`方法修改了对象的属性的`get`和`set`方法吧。\n\n### 抽象类\n\n在定义很多通用的调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。\n\n- 抽象方法，必须存在于抽象类中。\n- 抽象类是使用`abstract`声明的类。\n- 抽象类是不能被实例的话（也就是不能通过`new`创建）。\n- 抽象方法必须被子类实现，否则该子类必须是一个抽象类。\n\n```typescript\nfunction makeArea(shape: Shape) {\n  return shape.getArea();\n}\n\nabstract class Shape {\n  abstract getArea(): number;\n}\n\nclass Rectangle extends Shape {\n  private width: number;\n  private height: number;\n\n  constructor(width: number, height: number) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Circle extends Shape {\n  private r: number;\n\n  constructor(r: number) {\n    super();\n    this.r = r;\n  }\n\n  getArea() {\n    return this.r * this.r * 3.14;\n  }\n}\n\nconst rectangle = new Rectangle(20, 30);\nconst circle = new Circle(10);\n\nconsole.log(makeArea(rectangle));\nconsole.log(makeArea(circle));\n```\n\n这里思考重写重载区别：重写是指的是子类继承父类并重新定义父类同名方法，重载则是一个函数多个类型定义。\n\n### 类的类型\n\n类本身也可以作为一种数据类型。\n\n```typescript\n//声明一个类\nclass Person {\n  name: string = \"123\";\n  eating() {}\n}\n//创建一个对象，设置为Person类型，必须有相同的属性\nconst p1: Person = {\n  name: \"why\",\n  eating() {},\n};\n```\n\n## 接口的使用\n\n### 接口的声明\n\n前面我们可通过`type`来声明一个对象类型。\n\n```typescript\ntype InfoType = { name: string; age: number };\n```\n\n我们现在可以通过接口来实现：\n\n```typescript\ninterface IInfoType {\n  readonly name: string;\n  age: number;\n  friend?: {\n    name: string;\n  };\n}\nconst info: IInfoType = {\n  name: \"why\",\n  age: 18,\n  friend: {\n    name: \"kobe\",\n  },\n};\n```\n\n### 索引类型\n\n有时候我们需要定义很多属性，但实际其属性名都为相同的数据类型。\n\n```typescript\ninterface IndexLanguage {\n  [index: number]: string;\n}\n\nconst frontLanguage: IndexLanguage = {\n  0: \"HTML\",\n  1: \"CSS\",\n  2: \"JavaScript\",\n  3: \"Vue\",\n};\n\ninterface ILanguageYear {\n  [name: string]: number;\n}\n\nconst languageYear: ILanguageYear = {\n  C: 1972,\n  Java: 1995,\n  JavaScript: 1996,\n  TypeScript: 2014,\n};\n```\n\n### 函数类型\n\n接口也可以用来定义函数类型\n\n```typescript\ninterface CalcFn {\n  (n1: number, n2: number): number;\n}\n\nfunction calc(num1: number, num2: number, calcFn: CalcFn) {\n  return calcFn(num1, num2);\n}\n\nconst add: CalcFn = (num1, num2) => {\n  return num1 + num2;\n};\n\ncalc(20, 30, add);\n```\n\n当然一般还是推荐用类型别名来定义函数：\n\n```typescript\ntype CalcFn = (n1: number, n2: number) => number;\n```\n\n### 接口继承\n\n接口也可以继承，而且支持多继承\n\n```typescript\ninterface ISwim {\n  swimming: () => void;\n}\n\ninterface IFly {\n  flying: () => void;\n}\n\ninterface IAction extends ISwim, IFly {}\n\nconst action: IAction = {\n  swimming() {},\n  flying() {},\n};\n```\n\n### 交叉类型\n\n联合类型表示多个类型中一个即可，还有另外一种类型合并，就是交叉类型（`Intersection Types`）。交叉类似表示需要满足多个类型的条件，交叉类型使用 `&` 符号。\n\n```typescript\ntype WhyType = number & string; //WhyType就是never 当然是无意义的\n```\n\n我们一般对对象使用交叉类型\n\n```typescript\ninterface ISwim {\n  swimming: () => void;\n}\n\ninterface IFly {\n  flying: () => void;\n}\n\ntype MyType1 = ISwim | IFly;\ntype MyType2 = ISwim & IFly;\n\nconst obj1: MyType1 = {\n  flying() {},\n\n  swimming() {},\n};\n\nconst obj2: MyType2 = {\n  swimming() {},\n  flying() {},\n};\n```\n\n### 构造函数的类型接口\n\n这种情况是将一个构造函数作为参数传入函数，加上 new 作为与普通函数定义的区别。\n\n```ts\nclass Animal {\n  constructor(public name: string) {}\n}\n//不加new是修饰函数的,加new是修饰类的\ninterface WithNameClass {\n  new (name: string): Animal;\n}\nfunction createAnimal(clazz: WithNameClass, name: string) {\n  return new clazz(name);\n}\nlet a = createAnimal(Animal, \"hello\");\nconsole.log(a.name);\n```\n\n### 接口定义任何属性\n\n如果我们在定义接口的时候无法预先知道有什么属性，或者我们需要添加额外的一些未知属性。\n当然注意这个属性名的类型只能是 number，string，symbol 或者模版文本类型。\n\n```ts\ninterface Prerson {\n  id: number;\n  name: string;\n  [propName: string]: any; //这里的propName是任意取的\n}\n\nconst pr: Prerson = {\n  id: 111,\n  name: \"zamhsan\",\n  age: 18,\n};\n\nconsole.log(pr);\n```\n\n### 接口的实现\n\n通过类来实现接口，继承只能单继承，但是一个类可以实现多个接口。\n\n```typescript\ninterface ISwim {\n  swimming: () => void;\n}\n\ninterface IEat {\n  eating: () => void;\n}\n\n//类实现接口\nclass Animal {}\n//继承只能单继承，一个类可以实现多个接口\nclass Fish extends Animal implements ISwim, IEat {\n  constructor() {\n    super();\n  }\n  swimming() {\n    console.log(\"hahh\");\n  }\n  eating() {\n    console.log(\"hahh\");\n  }\n}\n\nfunction swimAction(swim: ISwim) {\n  swim.swimming();\n}\n\n//所有实现了接口的类的实例都是可以传入的\nswimAction(new Fish());\n```\n\n### interface 和 type 的区别\n\n这两者都可以用来定义对象类型。如果我们定义非对象类型，通常会推荐使用`type`，如果是定义对象类型，两者就有区别了。\n\n- `interface`可以重复的对某个接口来定义属性，最终会合并。\n- `type`只是定义的别名，但是别名不能重复。\n\n```typescript\ninterface IFoo {\n  name: string;\n}\n\ninterface IFoo {\n  age: number;\n}\n//同时定义两个相同名称的接口后一个会合并前一个接口中的属性\nconst foo: IFoo = {\n  name: \"zhangsan\",\n  age: 12,\n};\n//在window中定义一个属性\ninterface Window {\n  age: number;\n}\n//并不会报错了\nwindow.age = 19;\nconsole.log(window.age);\n//注意不要加上  export {} 否者上面还是会报错，毕竟这个window在浏览器中才有的\n```\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801161002800.png#id=T7dK6&originHeight=159&originWidth=589&originalType=binary&ratio=1&status=done&style=none)\n\n```typescript\n//会报错\ntype Bar = {\n  name: string;\n};\ntype Bar = {\n  age: 18;\n};\n```\n\n### 接口和类型别名的区别\n\n在大多数情况下，接口和类型别名没有差别，只有特殊场景下有一些区别\n\n1. 基础数据类型与接口不同，接口往往表示的是一个对象的形状，类型别名还可以用于其它类型，基本类型，联合类型，元祖等。\n\n```ts\n// primitive\ntype Name = string;\n\n// union\ntype PartialPoint = PartialPointX | PartialPointY;\n\n// tuple\ntype Data = [number, string];\n\n// dom\nlet div = document.createElement(\"div\");\ntype B = typeof div;\n```\n\n2. 接口重复定义会被合并为单个接口，而类型不允许重复定义。\n\n```ts\ninterface Name1 {\n  first: string;\n}\ninterface Name1 {\n  last: string;\n}\ntype name2 = string;\n```\n\n3. 扩展方式不一样\n\n接口的扩展方式是通过继承实现，而类型别名是通过交叉类型实现。\n\n```ts\ninterface Name3 {\n  last: string;\n}\n\ninterface Name1 extends Name3 {\n  first: string;\n}\n\ntype name2 = string & Name1;\n```\n\n### 字面量赋值\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801161355849.png#id=yPdP8&originHeight=255&originWidth=330&originalType=binary&ratio=1&status=done&style=none)\n\n上面的代码是因为不符合接口定义的类型而报错，但是我们将该对象先赋值给一个变量，然后再将变量赋值给这个接口定义那就不会报错。\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801161536469.png#id=OnMBI&originHeight=440&originWidth=197&originalType=binary&ratio=1&status=done&style=none)\n\n那是因为我们将一个变量标识符赋值给其他变量的时候会进行擦除操作，上述代码就是擦除了 address 这个属性，发现剩下的属性是刚好满足的那就编译通过，但是擦除后剩下的属性类型还是不满足的话编译还是会报错的。\n\n## 泛型\n\n我们可以通过函数来封装一些`API`，通过传入不同的函数参数，让函数帮助我们完成不同的操作。\n比如我们定义一个函数，传入一个参数就会返回对应类型的值，如果使用`any`的话返回的都是`any`类型，我们要实现传入一个`number`类型值，返回的也是`number`。\n\n```typescript\nfunction sum<T>(num: T): T {\n  return num;\n}\n\n//方式一，明确传入类型\nsum<number>(12);\n\n//方式二，类型推导\nsum(50); //但是会推导为字面量类型\n```\n\n### 定义接口我们也可以使用泛型\n\n```typescript\ninterface IPerson<T1, T2, T3 = string> {\n  //可以设置默认类型，与函数参数默认值一样\n  name: T1;\n  age: T2;\n  address: T3;\n}\n//接口是没有类型推导的，x传入确切的类型\nconst p: IPerson<string, number> = {\n  name: \"zhang\",\n  age: 18,\n  address: \"zhangsan\",\n};\n```\n\n### 泛型类\n\n```typescript\nclass Point<T> {\n  x: T;\n  y: T;\n  z: T;\n\n  constructor(x: T, y: T, z: T) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n}\nconst p = new Point<string>(\"1.3\", \"1.6\", \"1.7\");\nconst p1 = new Point<number>(1, 2, 3);\n```\n\n另外还有泛型函数，泛型类型别名等用法。\n\n```ts\ntype Cart<T> = { list: T[] } | T[];\nlet c1: Cart<string> = { list: [\"1\"] };\nlet c2: Cart<number> = [1];\n\nfunction firstName<T>(name: T) {\n  console.log(name);\n}\n```\n\n### 泛型约束\n\n我们希望传入的数据类型都有某些共同的性质，比如都要有某些属性才允许传入。\n这里注意要和 extends 区分开。\n\n```typescript\ninterface ILength {\n  length: number;\n}\n\nfunction getLength<T extends ILength>(arg: T) {\n  return arg.length;\n}\n\n//只要有length就可以传进来\ngetLength([\"abc\"]);\ngetLength(\"abc\");\ngetLength({ length: 100 });\n```\n\n### 默认泛型类型\n\n当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\n```ts\nfunction createArray<T = string>(length: number, value: T): Array<T> {\n  let result: T[] = [];\n  for (let i = 0; i < length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\n```\n\n## 实用技巧\n\n### typeof\n\n`typeof`既可以用作类型保护，也可以用来推理类型。\n\n```ts\nlet p = {\n  name: \"zhangsan\",\n  age: 19,\n};\n\ntype pname = typeof p;\n```\n\n### keyof\n\n`keyof` 可以用来取得一个对象接口的所有 `key` 值。\n\n```ts\n//检查输入的属性是否为对象的属性\n//T[K] 表示 类型T 属性K 的类型\nfunction getProps<T, K extends keyof T>(o: T, name: K[]): T[K][] {\n  return name.map((n) => o[n]);\n}\n\nconsole.log(\n  getProps({ name: \"zhangsan\", age: 18, flag: true }, [\"name\", \"age\", \"flag\"])\n);\n\ninterface Person {\n  name: string;\n  age: number;\n  gender: \"male\" | \"female\";\n}\n//type PersonKey = 'name'|'age'|'gender';\ntype PersonKey = keyof Person;\n\nfunction getValueByKey(p: Person, key: PersonKey) {\n  return p[key];\n}\nlet val = getValueByKey({ name: \"hello\", age: 10, gender: \"male\" }, \"name\");\nconsole.log(val);\n```\n\n### 索引访问操作符\n\n使用[] 操作符可以进行索引访问。\n\n```ts\ninterface p {\n  name: string;\n  age: number;\n}\n\ntype pp = p[\"name\"];\n```\n\n### 映射类型 in\n\n可以使用 in 来批量操作类型中的属性\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype Person_part = {\n  [key in keyof Person]?: Person[key];\n};\n```\n\n### infer\n\ninfer 可以在 extends 条件类型的字句中，在真实的分支中引用此推断类型变量，推断待推断的类型。\n\n#### 使用 infer 推断函数返回类型\n\n```ts\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n\ntype fn = () => number;\ntype fnReturnType = ReturnType<fn>; // number\n```\n\n上述 T extends U ? X : Y 的形式为条件类型。\n\n意思就是如果 T 能继承 U 则返回类型就为 X 否者为 Y，在这个例子中 T 为一个函数，可以继承 (..args:any[]) => infer R 这种形式，所以返回值 为 infer R，所以 变量 R 就为 number。\n\n#### 反解 promise\n\n```ts\n// promise 响应类型\ntype PromiseResType<T> = T extends Promise<infer R> ? R : T;\n\n//这个函数返回值推导为Promise<string>\nasync function strPromise() {\n  return \"string promise\";\n}\n\ninterface Person {\n  name: string;\n  age: number;\n}\nasync function personPromise() {\n  return {\n    name: \"p\",\n    age: 12,\n  } as Person;\n}\n\ntype StrPromise = ReturnType<typeof strPromise>; // Promise<string>\n// 反解\ntype StrPromiseRes = PromiseResType<StrPromise>; // str\n\ntype PersonPromise = ReturnType<typeof personPromise>; // Promise<Person>\n// 反解\ntype PersonPromiseRes = PromiseResType<PersonPromise>; // Person\n```\n\n#### 反解函数参入参类型\n\n```ts\ntype Fn<T> = (arg: T) => void;\n\ntype FnArg<U> = U extends Fn<infer A> ? A : any;\n\nfunction fn(name: string) {\n  console.log(name);\n}\n\ntype ArgTp = FnArg<typeof fn>; //string\n```\n\n#### 元组类型转联合类型\n\n```ts\ntype ElementOf<T> = T extends Array<infer A> ? A : never;\n\ntype TTuple = [string, number];\n\nconst arr: TTuple = [\"zhangsan\", 18];\n\ntype Union = ElementOf<typeof arr>;\n```\n\n#### new 操作符\n\n```ts\n// 获取参数类型\ntype ConstructorParameters<T extends new (...args: any[]) => any> =\n  T extends new (...args: infer P) => any ? P : never;\n\n// 获取实例类型\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (\n  ...args: any[]\n) => infer R\n  ? R\n  : any;\n\nclass TestClass {\n  constructor(public name: string, public string: number) {}\n}\n\ntype Params = ConstructorParameters<typeof TestClass>; // [string, numbder]\n\ntype Instance = InstanceType<typeof TestClass>; // TestClass\n```\n\n这里要注意，当我们定义一个类的时候，会获得两个类型。\n\n```ts\nclass Component {\n  static myName: string = \"静态名称属性\";\n  myName: string = \"实例名称属性\";\n}\n//ts 一个类型 一个叫值\n//放在=后面的是值\nlet com = Component; //这里是代表构造函数\n\n//冒号后面的是类型\nlet c = new Component(); //这里是代表实例类型\nlet f: typeof Component = com;\n\nconsole.log(typeof c, typeof f);\n```\n\n#### 另类练习\n\n```ts\n// 定义一个函数，第一个参数是一个只有一个参数的函数，要求第二个参数的类型为第一个参数函数的参数类型\n\ntype ReducerState<T> = (arg: T) => T;\n\ntype ReducerStateInfer<U extends ReducerState<any>> = U extends ReducerState<\n  infer I\n>\n  ? I\n  : never;\n\nfunction reducer<R extends ReducerState<any>>(\n  fun: R,\n  arg: ReducerStateInfer<R>\n) {\n  return fun(arg);\n}\n\nconst num = (count: number) => count + 1;\n\nconsole.log(reducer(num, 100));\n```\n\n### 内置工具\n\n这里介绍下 ts 内置的一些工具集\n\n#### Exclude<T,U>\n\n从 T 可分配的类型中剔除 U。\n\n```ts\ntype Exclude<T, U> = T extends U ? never : T;\n\ntype E = Exclude<string | number, string>;\n//上述我个人理解的额是等同于以下形式\ntype E = Exclude<string , string> ｜ Exclude<number, string>;\nlet e: E = 10;\n```\n\n#### Extract<T,U>\n\n从 T 可分配给的类型中提取 U\n\n```ts\ntype Extract<T, U> = T extends U ? T : never;\n\ntype E = Extract<string | number, string>;\nlet e: E = \"1\";\n```\n\n#### NonNullable<T>\n\n从 T 中排出 null 和 undefined\n\n```ts\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype E = NonNullable<string | number | null | undefined>;\nlet e: E = null;\n```\n\n#### 基于 infer 实现的一些类型\n\n- ReturnType 返回函数的返回值类型\n- Parameters 获取函数的参数类型\n\n#### Partial\n\n将传入属性转换为可选属性\n\n```ts\ntype Partial<T> = { [P in keyof T]?: T[P] };\ninterface A {\n  a1: string;\n  a2: number;\n  a3: boolean;\n}\ntype aPartial = Partial<A>;\nconst a: aPartial = {}; // 不会报错\n```\n\n#### Required\n\n将可选属性转为必选属性\n\n```ts\ntype Required<T> = { [P in keyof T]-?: T[P] };\ninterface Person {\n  name: string;\n  age: number;\n  gender?: \"male\" | \"female\";\n}\n\nlet p: Required<Person> = {\n  name: \"hello\",\n  age: 10,\n  gender: \"male\",\n};\n```\n\n#### Readonly\n\n将传入的属性都加上只读前缀\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n  gender?: \"male\" | \"female\";\n}\n//type Readonly<T> = { readonly [P in keyof T]: T[P] };\nlet p: Readonly<Person> = {\n  name: \"hello\",\n  age: 10,\n  gender: \"male\",\n};\np.age = 11; //error\n```\n\n#### Pick<T,k>\n\n从传入的属性中提取特定的属性出来\n\n```ts\ninterface Todo {\n  title: string;\n  description: string;\n  done: boolean;\n}\n\ntype Pick<T, K extends keyof T> = { [P in K]: T[P] };\n\ntype TodoBase = Pick<Todo, \"title\" | \"done\">;\n\ntype TodoBase = {\n  title: string;\n  done: boolean;\n};\n```\n\n#### Record<K,T>\n\n构造一个类型，该类型具有一组属性 K，每个属性的类型为 T。\n\n```ts\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\ntype Point = \"x\" | \"y\";\ntype PointList = Record<Point, { value: number }>;\nconst cars: PointList = {\n  x: { value: 10 },\n  y: { value: 20 },\n};\n```\n\n#### Omit<K,T>\n\n用于将传入的属性剔除特定属性并返回新的类型。\n\n```ts\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n};\n\ntype UserWithoutEmail = Omit<User, \"email\">;\n//没有email的类型声明了\n```\n\n## 装饰器\n\n暂时不了解\n\n## tsconfig.json\n\n该文件是 typescript 项目的配置文件，包含 typescript 相关编译配置，如果一个目录下存在一个 tsconfig.json 文件，那么它意味着这个目录是 TypeScript 项目的根目录。\n\n### 重要编译选项\n\n- files - 设置要编译的文件的名称。\n- include - 设置需要进行编译的文件，支持路径模式匹配。\n- exclude - 设置无需进行编译的文件，支持路径模式匹配。\n- compilerOptions - 设置与编译流程相关的选项。\n\n详细的配置介绍：\ncompilerOptions 选项：\n\n```json\n{\n  \"compilerOptions\": {\n    /* 基本选项 */\n    \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [], // 指定要包含在编译中的库文件\n    \"allowJs\": true, // 允许编译 javascript 文件\n    \"checkJs\": true, // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true, // 生成相应的 '.d.ts' 文件\n    \"sourceMap\": true, // 生成相应的 '.map' 文件\n    \"outFile\": \"./\", // 将输出文件合并为一个文件\n    \"outDir\": \"./\", // 指定输出目录\n    \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true, // 删除编译后的所有的注释\n    \"noEmit\": true, // 不生成输出文件\n    \"importHelpers\": true, // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true, // 启用所有严格类型检查选项\n    \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true, // 启用严格的 null 检查\n    \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录\n    \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [], // 包含类型声明的文件列表\n    \"types\": [], // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true, // 启用装饰器\n    \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持\n  }\n}\n```\n\n## 声明文件\n\n声明文件的作用是代码补全和语法提示。\n通常我们会把声明语句单独的放到一个单独的文件，这个文件就是声明文件（`xxx.d.ts`），声明文件的文件扩展名是：`.d.ts`\n常用的声明语句：\n● `declare var` 声明全局变量\n● `declare function` 声明全局方法\n● `declare class `声明全局类\n● `declare enum` 声明全局枚举类型\n● `declare namespace` 声明（含有子属性的）全局对象\n● `interface` 和 `type` 声明全局类型\n● `export` 导出变量\n● `export` `namespace` 导出（含有子属性的）对象\n● `export default ES6` 默认导出\n● `export = commonjs` 导出模块\n● `export as namespace UMD` 库声明全局变量\n● `declare global` 扩展全局变量\n● `declare module` 扩展模块\n● `///` 三斜线指令 [用法](https://www.cnblogs.com/kunmomo/p/15272695.html)\n\n### 书写声明文件\n\n#### 自动生成\n\n如果库的源码本身就是由 `ts` 写的，那么在使用 `tsc `脚本将`ts` 编译为` js` 的时候，添加 `declaration` 选项，就可以同时也生成 `.d.ts `声明文件了。\n\n#### 手动书写\n\n当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。\n在不同的场景下，声明文件的内容和使用方式会有所区别。\n[详情](https://ts.xcatliu.com/basics/declaration-files.html#mo-kuai-cha-jian)\n\n## 命名空间\n\n将一个模块内部在进行划分作用域。\n\n```typescript\nexport namespace time {\n  export function format(time: number) {\n    return \"2074-02-22\";\n  }\n}\n```\n\n```typescript\n//将函数包裹到命名的对象中导出使用\nimport { time } from \"./utils/format\";\nconsole.log(time.format(1));\n```\n\n### 类型的查找\n\n在 TS 中所有类型几乎都是我们自己编写的 ，但是还有一些我们并没有编写的类型也可使用，这是因为 TS 内部为我们声明了很多类型。\n\n```typescript\nconst img = document.getElementById(\"img\") as HTMLImageElement;\n```\n\n上述的 `HTMLImageElement` 等类型就是`TS`内部声明好了的，我们在`vscode`可以通过`ctrl+`左键点击进入声明文件。\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801165054004.png#id=XUx8m&originHeight=751&originWidth=1252&originalType=binary&ratio=1&status=done&style=none)\n\n像这样的`.d.ts`文件就是用来做类型声明的文件，它仅仅用来做类型检测，告知`TS`有哪些类型。`TS`会在三个地方找到我们类型声明：\n\n- 内置类型声明\n- 外部定义类型声明\n- 自己定义类型声明\n\n内置类型声明就是 TS 自带的。\n\n外部定义类型的声明就是我们使用一些第三方库的时候它有一个`.d.ts`文件声明了类型。\n\n这些库通常有两种方式声明类型，一种是自带的(比如`axios`)，另一种需要单独下载（比如`lodash`）。下载模版是@types/模块名称\n我们在 TS 引入这些库，如果没有类型声明就会报错，我们当然也可以自己编写声明。\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801165706105.png#id=cyDqK&originHeight=43&originWidth=204&originalType=binary&ratio=1&status=done&style=none)\n\n这个变量是没有定义的，当然会报错\n\n![](https://zhanghengtuchaung.oss-cn-chengdu.aliyuncs.com/img/image-20210801165733585.png#id=fpZ4C&originHeight=99&originWidth=388&originalType=binary&ratio=1&status=done&style=none)\n\n定义之后就不会报错了。\n另外我们还可以声明函数，类\n\n```typescript\ndeclare function name(): void;\ndeclare class Person {\n  name: string;\n  constructor(name: string);\n}\n```\n\n声明模块\n\n如果某模块不能使用，我们可以自己声明。在声明模块的内部，我们可以通过 export 导出对应库的类、函数等。\n\n语法： `declare module '模块名' {}`\n\n```typescript\ndeclare module \"lodash\" {\n  export function join(args: []): any;\n}\n```\n\n声明文件\n\n在开发 vue 的过程中，默认是不识别我们的.vue 文件的，那么我们就需要对其进行文件的声明。在开发 vue 的过程中，默认是不识别我们的.vue 文件的，那么我们就需要对其进行文件的声明。\n\n```typescript\ndeclare module \"*.vue\";\ndeclare module \"*.jpg\";\ndeclare module \"*.jpeg\";\ndeclare module \"*.png\";\ndeclare module \"*.svg\";\ndeclare module \"*.gif\";\n```\n\n### 声明命名空间\n\n比如我们引入了 JQuery，就可以声明命令空间\n\n```typescript\ndeclare namespace $ {\n  function ajax(settings: any): void;\n}\n```\n\n在 TS 中就可以这样使用\n\n```typescript\n$.ajax({\n  //...\n});\n```\n\n## 发布声明文件\n\n如果是我们为第三方库添加声明文件，如果作者不愿合并我们提交的`pr` 那么我们可以自己将声明文件提交到`@types`，之后其他人下载就可以通过下载`@types/xx`来进行文件的下载。\n与普通的`npm`模块不同，`@types` 是统一由 `DefinitelyTyped` 管理的。要将声明文件发布到 @types 下，就需要给 `DefinitelyTyped `创建一个 `pull-request`，其中包含了类型声明文件，测试代码，以及 `tsconfig.json` 等。\n\n`pull-request` 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 @`types` 下。\n在 `DefinitelyTyped` 中创建一个新的类型声明，需要用到一些工具，`DefinitelyTyped` 的文档中已经有了详细的介绍，这里就不赘述了，以官方文档为准。\n\n\n",
      "type": 1,
      "id": 4
    },
    {
      "title": "正则表达式",
      "context": "## 正则字符匹配规则\n\n### 模糊匹配\n\n正则之所以强大是因为它可以进行模糊匹配，如果单纯的使用精准匹配那是没有多大意义的。\n\n```javascript\nconst reg = /hello/;\n\nconsole.log(reg.test(\"hello world\")); //仅仅匹配hello这个字符\n```\n\n正则的模糊匹配分为两种：横行模糊和纵向模糊。\n\n#### 横向模糊\n\n横向的模糊指的是匹配，一个正则可匹配的字符串长度不是固定的。\n实现方式是使用量词进行约束，比如 `{m,n}`,其意义是连续出现最少为 `m`次，最多为 `n`次。\n\n```javascript\nconst reg = /hello/;\n//如果不加 g就只会匹配到一次  加上g就会匹配 helloo world，hellooo world，helloooo world，hellooooo world\nconst reg1 = /hello{2,5} world/g;\n\nconsole.log(reg.test(\"hello world\"));\nconsole.log(\"hellooooo world\".match(reg1));\n```\n\n其中我们有一个字符 `g`在正字表达式后边，它是一个正则修饰符，表示全局匹配。而不单指匹配一次。\n\n#### 纵向模糊\n\n纵向模糊匹配指的是一个正则匹配到某一字符串，它可以不是某个确定的字符。\n实现方式是使用字符组表示，比如 `[abc]`表示的是该字符可以是 `a，b，c`中的任何一个。\n\n### 字符组\n\n字符组表示法 例如，`[abc]`表示匹配 `abc`这三个字符中的其中一个。\n\n#### 范围表示\n\n当然如果要匹配很多种字符，你可以一个一个的写出，比如匹配 26 个英文字符你就直接写出来 `[abcdefg...]`。额当然这太麻烦了，这里可以使用-来表示范围。比如匹配所有的小写字母 `[a-z]`，所有的大写字母 `[A-Z]`，所有的数字 `[0-9]`。当然要注意，如果你要匹配所有的英文字母千万不能写成 `[A-z]`,因为这个范围指根据 ASCII 表来界定的，上述还包含来一些特殊字符，所以要匹配所有的英文字符就写成 `[A-Za-z]`即可。\n另外如果要匹配 `a``-``z`这三个字符中的其中一个我们可以打乱顺序来表示，比如写成： `[-az]`,`[az-]`或者最终方法---转义 `[a\\-z]`。\n\n#### 排除字符组\n\n如果我们要排除匹配一些字符可以在上述基础上加上 `^`好，比如排除匹配所有小写字符写为 `[^a-z]`，另外注意，字符组里的 `^`和直接写在外层的 `^`不是同一个意思，比如 `/^a/`这个正则中的^表示匹配开头的位置，而字符组里的 `^`表示排除字符，表示求反的意思。\n\n#### 一些表示字符范围的字符组简写\n\n以下是常用的表示字符范围的字符组简写。\n\n- `\\d `就是`[0-9]` 表示一位数字。\n- `\\D` 就是`[^0-9]` 表示除了数字以外的字符。\n- `\\w` 就是`[0-9a-zA-Z_]` 表示数字、大小写字母和下划线。记忆方式：`w`是`word`的简写，也称单词字符。\n- `\\W` 是`[^0-9a-zA-Z_] `非单词字符。\n- `\\s` 是`[ \\t\\v\\n\\r\\f]` 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：`s`是`space character`的首字母。\n- `\\S` 是`[^ \\t\\v\\n\\r\\f] ` 非空白符。\n- `[\\u4E00-\\u9FFF] `表示匹配常用的汉字。注意这里不是所有的汉字。只包括了常用的简繁体，当然也是非常够用了。\n- `. `就是`[^\\n\\r\\u2028\\u2029] `通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。\n\n另外如果要匹配任意的字符，就上述互相为反的字符组组合在一起就行了，比如：\n`[\\w\\W]`, `[\\d\\D]`,` [\\s\\S]`和 `[^]`其中一个。\n\n### 量词\n\n表示匹配某些字符特定次数。\n首先理解 `{m,n}`表示匹配出现次数至少 `m`，至多 `n`次。\n\n#### 常见简写形式\n\n- `{m,} `表示至少出现`m`次。\n- `{m}` 表示出现 m 次，等价于`{m,m}`。\n- `?` 等价于`{0,1}`，表示出现或者不出现。记忆方式：问号的意思表示，有吗？\n- `+`等价于`{1,}`，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。\n- `*`等价于`{0,}`，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。\n\n#### 贪婪匹配和惰性匹配\n\n例 1:\n\n```javascript\nvar regex = /\\d{2,5}/g;\nvar string = \"123 1234 12345 123456\";\nconsole.log(string.match(regex));\n// => [\"123\", \"1234\", \"12345\", \"12345\"]\n```\n\n上述的正则表示匹配连续出现 2-5 次的数字。通过匹配结果可以得出，确实是将所有的情况都匹配到了。这其实就是贪婪匹配。当第一次匹配到了两位数后，正则并不会觉得“满足” ，还会继续找符合条件的字符。\n例 2:\n\n```javascript\nvar regex = /\\d{2,5}?/g;\nvar string = \"123 1234 12345 123456\";\nconsole.log(string.match(regex));\n// => [\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"]\n```\n\n注意我们这个例子中在量词后面加上了一个? 当然这个 `?`并不是量词了哈。在量词后面加上 `?`表示惰性匹配。而查看匹配结果可以得到，正则只会匹配两个。而不是所有情况都去考虑。\n开启惰性匹配就只需要在量词表示符后加上一个?即可。\n\n### 多选分支\n\n多选分支支持多个子模式任选其一进行字符匹配。\n具体形式如，`(p1|p2|p3)` `p1` `p2` `p3`表示子模式，中间用管道符 `|`分隔。 比如要匹配 `hello`和 `world`这两个字符中的一个，正则表达式如下：\n\n```javascript\nconst reg = /hello|world/g;\nconsole.log(\"hello,nihao\".match(reg));\nconsole.log(\"world,nihao\".match(reg));\n```\n\n另外注意，多选分支是惰性的，比如我们用正则 `/good|goodbye/`去匹配 `goodbye`,匹配结果会是 `good`。\n\n```javascript\nconst reg = /good|goodbye/g;\nconsole.log(\"goodbye\".match(reg));\n// ['good']\n```\n\n当前面的条件匹配后，就不会去匹配后面的模式了\n\n### 常见匹配案例\n\n#### 匹配 16 进制的颜色字符串\n\n要求匹配：\n3 位或者 6 位的的英文数字字符。\n分析：\n英文字符范围为 `A-F`，`a-f` ，数字为 0-9,开头为 `#`。\n因为要匹配 3 位或者 6 位所以需要使用分支。使用分支注意顺序，6 位匹配的在前，保证不会因为惰性匹配而匹配错误。\n\n```javascript\n/* \n  要求匹配以下字符\n  #bfa\n  #bbffaa\n  #BBfFaa\n  #12DCF1\n*/\n\nconst reg = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;\nconsole.log(\"#bfa #ccc #bff\".match(reg));\n```\n\n#### 匹配时间\n\n要求匹配：\n23:59，03:26。\n分析：\n共四位数字，第一位可以是[0-2]。第二位在第一位是[0-1]的时候可以为[0-9]，当第一位是 2 的时候只能为[0-3]。第三位可以为[0-5]，第四位可以为[0-9]。\n\n```javascript\nconst reg = /^(0?[0-9]|[1][0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;\nconsole.log(reg.test(\"9:8\"));\n```\n\n上述的正则还包含了匹配 7:8 这种格式。\n\n#### 匹配日期\n\n要求匹配：\nyyyy-mm-dd\n分析：\n年份是四位随机数字，月份最大 12，有 0[1-9]和 1[0-2]两种情况，日期最大 31，有[0][1-9],[12][0-9]和 3[01]三种情况。注意这里的正则是不考虑日期是否是现实中的日期，比如 2 月 30 日这种情况。\n\n```javascript\nconst reg = /^[\\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\nconsole.log(reg.test(\"2028-02-30\"));\n```\n\n#### 匹配 window 盘符路径\n\n要求匹配：\n\n```\nF:\\study\\javascript\\regex\\regular expression.pdf\n\nF:\\study\\javascript\\regex\\\n\nF:\\study\\javascript\n\nF:\\\n```\n\n分析：\n首先第一部分盘符是 `a-zA-z:\\`。第二部分为 `xxx\\xxx\\xxx\\`,文件夹不能有特殊字符 比如 `\\ / : * ? \" < > → | \\r \\n`,可以有有任意个。最后的 `xxx`表示这个路径为一个文件,也可以没有。注意转义。\n\n```javascript\nconst reg = /^[a-z|A-Z]:\\\\([^^\\\\/:*?\"<>|\\r\\n]+\\\\)*([^^\\\\/:*?\"<>|\\r\\n]+)?$/;\nconsole.log(reg.test(\"F:\\\\\"));\n```\n\n#### 匹配 html 标签中的 id\n\n要求匹配：\n\n```html\n//提取id=\"container\"\n<div id=\"container\" class=\"main\"></div>\n```\n\n可能一开始就会想到：\n\n```javascript\nconst test = `<div id=\"container\" class=\"h1-header\">`;\nconst reg1 = /id=\".*\"/;\nconsole.log(test.match(reg1)[0]);\n// id=\"container\" class=\"h1-header\"\n```\n\n但是实际上上述会直接匹配到最后一个\",因为正则的贪婪，当然你可能会想到加上?开启惰性匹配，当然功能是可以实现：\n\n```javascript\nconst test = `<div id=\"container\" class=\"h1-header\">`;\n\nconst reg1 = /id=\".*?\"/;\nconsole.log(test.match(reg1)[0]);\n// id=\"container\"\n```\n\n但是这里会有个问题就是效率比较低，因为其匹配原理会涉及到“ [回溯](#ref) ”这个概念。可以优化如下：\n\n```javascript\nconst test = `<div id=\"container\" class=\"h1-header\">`;\n\nconst reg = /id=\"[^\"]*\"/;\nconsole.log(test.match(reg)[0]);\n// id=\"container\"\n```\n\n## 正则位置匹配规则\n\n上一部分将来字符匹配，这里记住一句话，正则要么匹配位置要么匹配字符。\n下图的箭头所指的位置就是位置，指的字符与字符之间的位置，加上开头和字符，结尾和字符的位置。\n\n![请输入图片描述](https://topzhang.cn/usr/uploads/2022/03/891802084.png)\n\n#### 匹配位置\n\n目前 `es6`有 8 个断言字符：\n\n| 字符   | 解释                                                                                       |\n| ------ | ------------------------------------------------------------------------------------------ |\n| ^      | 匹配开头，在多行匹配中匹配行开头，注意开启多行匹配就是加上修饰符 m                         |\n| $      | 匹配结尾，在多行匹配中匹配行结尾                                                           |\n| \\\\b    | 单词边界，具体就是\\\\w 和\\\\W 之间的距离。也包括\\\\w 和^之间的位置，也包括\\\\w 和$之间的位置。 |\n| \\\\B    | 非单词边界                                                                                 |\n| (?=p)  | 指的 p 前面的位置，p 是一个子模式                                                          |\n| (?!p)  | ?=p 的反面意思，指的不是 p 前面的位置                                                      |\n| (?<=p) | p 后面的位置                                                                               |\n| (?\n\n#### ^和$\n\n把字符的开头和结尾用#代替：\n\n```javascript\nconst str = \"hello\\nhello\";\nconsole.log(str.replace(/^|$/g, \"#\"));\n/* \n#hello\nhello#\n*/\n```\n\n多行匹配模式：\n\n```javascript\nconst str = \"hello\\nhello\";\nconsole.log(str.replace(/^|$/gm, \"#\"));\n/* \n#hello#\n#hello#\n*/\n```\n\n#### \\\\b 和\\\\B\n\n直接看案例：\n\n```javascript\nconst text = \"hello javascript\";\n\nconsole.log(text.replace(/\\b/g, \"#\"));\n//#hello# #javascript#\n```\n\n这里我们详细分析下结果：\n`\\w`指的是 `[0-9a-zA-Z]`中的任意一个，而 `\\W`指的是 `[^0-9a-zA-Z]`。\n然后我们一个一个分析#为什么插在那个位置：\n\n- 第一个`#`是因为开头满足`^`而第一个字符 h 满足`\\w`。\n- 第二个`#`是因为`o`满足`\\w`而空格满足`\\W`。\n- 第三个和第二个一样就是位置互换了下。\n- 第四个`t`满足`\\w`，而结尾满足`$`。\n\n上面展示了 `\\b`的效果，接下来展示一个 `\\B`案例。\n\n```javascript\nconst text = \"hello javascript\";\n\nconsole.log(text.replace(/\\B/g, \"#\"));\n//h#e#l#l#o j#a#v#a#s#c#r#i#p#t\n```\n\n这样我不用说也能理解了吧。\n\n#### **(?=p)和(?!p)**\n\n`(?=p)` 学名叫正向先行断言。\n\n`(?!p)` 学名叫负向先行断言。\n\n下面展示两个案例。 `(?=l)`表示字符 `l`的前面的位置，例如：\n\n```javascript\nvar result = \"hello\".replace(/(?=l)/g, \"#\");\nconsole.log(result);\n//he#l#lo\n```\n\n而 `(?!l)`就是不是 `l`前面的位置：\n\n```javascript\nvar result = \"hello\".replace(/(?!l)/g, \"#\");\nconsole.log(result);\n//#h#ell#o#\n```\n\n#### (?<=p)和(?<!p)\n\n`(?<=p)` 正向后行断言。\n`(?<!p)` 负向后行断言。\n展示案例：\n\n```javascript\nvar result = \"hello\".replace(/(?<=l)/g, \"#\");\nconsole.log(result);\n//hel#l#o\n```\n\n```javascript\nvar result = \"hello\".replace(/(?<!l)/g, \"#\");\nconsole.log(result);\n//#h#e#llo#\n```\n\n反正上面这四个断言就是一句话 看看左边，看看右边。\n另外注意 `(?=p)`，一般都理解成：要求接下来的字符与 `p`匹配，但不能包括 `p`的那些字符。我们只是要求能匹配到以 `p`为依据的位置，而匹配结果是不包括 `p`的。\n\n### 位置的特性\n\n位置可以理解为空字符串\"\"，比如\"hello\"可以拆分成以下部分组合。\n\n```javascript\n\"hello\" == \"\" + \"h\" + \"\" + \"e\" + \"\" + \"l\" + \"\" + \"l\" + \"o\" + \"\";\n```\n\n也可以等价于：\n\n```javascript\n\"hello\" == \"\" + \"\" + \"hello\";\n```\n\n因此 `/^hello$/`写成 `/^^hello?$/`也是一样的。当然不推荐后者的写法，毕竟可读性不强。\n另外还有一种更复杂的写法：\n\n```javascript\nconst result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test(\"hello\");\nconsole.log(result);\n//true\n```\n\n只要理解了位置的含义，这其实都是一样的意思。\n\n### 常见匹配案例\n\n#### 什么都不匹配的正则\n\n理解了位置后就很简单了\n`/.^/`通配符后边是开头，当然也可以写成 `/$./`,另外还可以使用 `/[^\\w\\W]/`等。\n\n#### 数字的千分位表示\n\n需要将 1234567 转为 1,234,567。\n分析:\n从后匹配每三个数字的位置，然后将这位置替换为,\n\n```javascript\nconst reg1 = /(?=(\\d{3})+$)/g;\nconsole.log(\"1234567\".replace(reg1, \",\"));\n//1,234,567\n```\n\n但是这有个问题就是开头的位置也会匹配到，比如数据为 123456789，那结果\n就为,123,456,789\n所以还需要将开头的位置排除掉，所以修改后的正则为：\n\n```javascript\nconst reg1 = /(?!^)(?=(\\d{3})+$)/g;\nconsole.log(\"123456789\".replace(reg1, \",\"));\n//123,456,789\n```\n\n另外我们如果遇到了这种形式的字符串 12345678 12345。\n我们需要转为 12,345,678 12,345。\n只需要将上述的正则中的开头和结尾中的 `^`和 `&`替换为 `\\b`即可。 这里细品下吧～～ 所以正则就成了 `/(?!\\b)(?=(\\d{3})+\\b)/g`。 开头的 `(?!\\b)`也等同于 `\\B`，所以最终的正则就为 `/\\B(?=(\\d{3})+\\b)/g`。\n\n#### 密码验证问题\n\n一般我们对密码的要求就是 6-12 位，要求包含大小写字母和数字中的其中两种字符。\n当然我们可以将这个条件拆成多个正则进行判断，但是这里我们详细分析下一个正则如何表达。\n首先不考虑至少包含其中两种字符，我们可以写出：\n\n```javascript\nvar reg = /^[0-9A-Za-z]{6,12}$/;\n```\n\n判断是否包含有一种字符：\n这里先要求包含数字,即位置后要有数字可以用 `?=.*[0-9]`表示，那么正则表示如下：\n\n```javascript\nvar reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;\n```\n\n以此类推，要求包含数字和小写字母：\n\n```javascript\nvar reg = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/;\n```\n\n所以我们可以将最先的要求分为以下几种情况：\n\n- 同时包含小写字母和数字。\n- 同时包含小写字母和大写字母。\n- 同时包含大写字母和数字。\n- 同时包含大写小写字母和数字(当然这个情况可以不写)。\n\n所以最终的正则形式如下：\n\n```javascript\nconst reg =\n  /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/;\nconsole.log(reg.test(\"1234567\")); // false 全是数字\nconsole.log(reg.test(\"abcdef\")); // false 全是小写字母\nconsole.log(reg.test(\"ABCDEFGH\")); // false 全是大写字母\nconsole.log(reg.test(\"ab23C\")); // false 不足6位\nconsole.log(reg.test(\"ABCDEF234\")); // true 大写字母和数字\nconsole.log(reg.test(\"abcdEF234\")); // true 三者都有\n```\n\n#### 解惑\n\n上面的正则有个 `(?=.*[0-9])^`。\n我们将这个正则分为两个部分 `(?=.*[0-9])`和 `^`。表示开头还有位置（当然开头的开头还是开头，即同一个位置），而 `(?=.*[0-9])`表示后面有任意一个字符，但是必须包含一个数字。总是就是从开头开始，后面要有一个数字。\n\n#### 另一种解法\n\n我们至少包含两种字符就是指的是不能全是数字，也不能全是大写字母，也不能全是小写字母。\n所以不能全是数字，对应的正则可以表示 `/?!^\\d{6,12}$/`\n\n```javascript\nconst reg = /(?!^\\d{6,12}$)^[0-9A-Za-z]{6,12}$/;\nconsole.log(reg.test(\"121131\"));\n```\n\n以此类推，三种都不能就可以表示如下：\n\n```javascript\nconst reg =\n  /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;\nconsole.log(reg.test(\"1234567\")); // false 全是数字\nconsole.log(reg.test(\"abcdef\")); // false 全是小写字母\nconsole.log(reg.test(\"ABCDEFGH\")); // false 全是大写字母\nconsole.log(reg.test(\"ab23C\")); // false 不足6位\nconsole.log(reg.test(\"ABCDEF234\")); // true 大写字母和数字\nconsole.log(reg.test(\"abcdEF234\")); // true 三者都有\n```\n\n## 正则表达式括号的作用\n\n正则表达式的括号简单来说就一句话，设置分组，便于我们引用。\n\n### 分组后和分支结构\n\n#### 分组\n\n`/a+/`表示匹配连续的 a，但是`/ab+/`表示匹配连续的 b，如果我们要匹配连续的`ab`就需要使用括号进行分组`/(ab)+/`,这样+就可以作用于这个整体了。\n\n#### 分支结构\n\n再多选分支结构`(p1|p2)`,括号就提供了多种子表达式选择。\n\n```js\n/* \n    匹配：\n       i love java\n       i love rust\n  */\n\nconst reg = /^(i love (java|rust)$/;\n```\n\n但是不加括号\n\n```js\nconst reg = /^i love java|rust$/;\n```\n\n这里因为`｜`优先级不高所以会匹配成`i love java` 和 `rust`。\n\n### 引用分组\n\n引用分组功能很强大，我们可以使用引用来进行更强大的提取和替换操作。\n\n示例,提取日期\n\n```js\nconst regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nconst string = \"2017-06-12\";\nconst result = string.replace(regex, function (match, year, month, day) {\n  console.log(match);\n  return month + \"/\" + day + \"/\" + year;\n});\nconsole.log(result);\n//\"06/12/2017\"\n```\n\n上述式子里，`match`表示是整体匹配结果，后面三个参数表示各个分组(括号)里面匹配的结果。\n\n使用`match`匹配:\n\n```js\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nvar string = \"2017-06-12\";\nconsole.log(string.match(regex));\n// => [\"2017-06-12\", \"2017\", \"06\", \"12\", index: 0, input: \"2017-06-12\"]\n```\n\n注意：如果正则后面有 g 修饰符，那么 match 烦的结果是不一样的。\n\n另外还可以使用`exec`方法 ：\n\n```js\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nvar string = \"2017-06-12\";\nconsole.log(regex.exec(string));\n/* \n[\n  '2017-06-12',\n  '2017',\n  '06',\n  '12',\n  index: 0,\n  input: '2017-06-12',\n  groups: undefined\n]\n*/\n```\n\n还可以使用构造函数的全局属性$1-$9 来进行替换\n\n```js\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nvar string = \"2017-06-12\";\nvar result = string.replace(regex, function () {\n  return RegExp.$2 + \"/\" + RegExp.$3 + \"/\" + RegExp.$1;\n});\nconsole.log(result);\n//06/12/2017\n```\n\n当然注意`$n`这种用法是非标准用法。\n也等价于以下写法：\n\n```js\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nvar string = \"2017-06-12\";\nvar result = string.replace(regex, function (match, year, month, day) {\n  return month + \"/\" + day + \"/\" + year;\n});\nconsole.log(result);\n```\n\n### 反向引用\n\n除了使用一些 api 来在外部使用引用分组，也可以在正则内部引用分组，但是只能引用之前出现的分组，即反向引用。\n案例：\n我们要匹配日期，支持以下三纵格式：\n2016-06-12\n2016/06/12\n2016.06.12\n\n最先想到可以写出如下正则：\n\n```js\nvar regex = /\\d{4}(-|\\/|\\.)\\d{2}(-|\\/|\\.)\\d{2}/;\nvar string1 = \"2017-06-12\";\nvar string2 = \"2017/06/12\";\nvar string3 = \"2017.06.12\";\nvar string4 = \"2016-06/12\";\nconsole.log(regex.test(string1)); // true\nconsole.log(regex.test(string2)); // true\nconsole.log(regex.test(string3)); // true\nconsole.log(regex.test(string4)); // true\n```\n\n可以看出中间的分隔符不一定都会匹配为一样的。但是我们需要前后统一的话就可以使用反向引用，保证后面匹配到的字符和前面一样。\n\n```js\nvar regex = /\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/;\nvar string1 = \"2017-06-12\";\nvar string2 = \"2017/06/12\";\nvar string3 = \"2017.06.12\";\nvar string4 = \"2016-06/12\";\nconsole.log(regex.test(string1)); // true\nconsole.log(regex.test(string2)); // true\nconsole.log(regex.test(string3)); // true\nconsole.log(regex.test(string4)); // false\n```\n\n这里面的`\\1`，表示的引用之前的那个分组`(-|\\/|\\.)`。不管它匹配到什么（比如`-`），`\\1`都匹配那个同样的具体某个字符。\n\n我们知道了`\\1`的含义后，那么`\\2`和`\\3`的概念也就理解了，即分别指代第二个和第三个分组。\n\n#### 嵌套括号\n\n好了看来你已经学会了反向分组了，那么遇到正则里面有嵌套括号的怎么办\n看如下的案例：\n\n```js\nvar regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;\nvar string = \"1231231233\";\nconsole.log(regex.test(string)); // true\nconsole.log(RegExp.$1); // 123\nconsole.log(RegExp.$2); // 1\nconsole.log(RegExp.$3); // 23\nconsole.log(RegExp.$4); // 3\n```\n\n其实这也很好理解，我们先从左开始看到第一个括号，里面嵌套的括号我们暂时忽略，所以第一个括号里就有三个`\\d`,所以这三个就视为一组，然后再看第二个括号，其中就一个`\\d`，这就是第二组，然后再看第三个括号，也是忽略里面的括号就是两个`\\d`,第三组。最后一组括号里就一个`\\d`，遇到嵌套括号就按照顺序匹配括号就行了，所以就是上面的输出结果了。\n\n#### \\10\n\n另外`\\10`表示什么意思？\n这里不要以为是`\\1`加上个`0`,这里就是第十组的意思。\n\n#### 引用不存在的分组\n\n我们在正则里引用不存在的分组并不会报错，而是会匹配反向引用的字符本身。例如`\\2`就会匹配`\"\\2\"` ，这里还要注意`\"\\2\"`对`\"2\"`进行了转义。\n\n```js\nvar regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/;\nconsole.log(regex.test(\"\\1\\2\\3\\4\\5\\6\\789\"));\nconsole.log(\"\\1\\2\\3\\4\\5\\6\\789\".split(\"\"));\n/*  \n  true\n[\n  '\\x01', '\\x02',\n  '\\x03', '\\x04',\n  '\\x05', '\\x06',\n  '\\x07', '8',\n  '9'\n]\n*/\n```\n\n我在 node 的环境下打印结果如上。\n\n#### 非捕获分组\n\n之前出现的分组我们都可以使用其引用，也成之前的为捕获型分组。\n\n如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)，例如本文第一个例子可以修改为：\n\n```js\nvar regex = /(?:ab)+/g;\nvar string = \"ababa abbb ababab\";\nconsole.log(string.match(regex));\n// => [\"abab\", \"ab\", \"ababab\"]\n```\n\n这样的目的其实是有利于性能优化的，之后讲到正则的回溯会了解到。\n\n### 常见案例\n\n#### trim 方法模拟\n\n两个思路，第一种是直接将首尾的空格匹配并替换\n\n```js\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nconsole.log(trim(\"  foobar   \"));\n// => \"foobar\"\n```\n\n第二个思路是匹配整个字符串然后再将引用提取出来相应的数据。\n\n```js\nfunction trim(str) {\n  return str.replace(/^\\s*(.*?)\\s*$/g, \"$1\");\n}\nconsole.log(trim(\"  foobar   \"));\n// => \"foobar\"\n```\n\n这里注意使用了惰性匹配，不然会匹配到除了最后一个空格外的前面所有的空格。\n\n#### 将配每个单词的首字母转为大写\n\n```js\nfunction titleize(str) {\n  return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) {\n    return c.toUpperCase();\n  });\n}\nconsole.log(titleize(\"my name is epeli\"));\n// => \"My Name Is Epeli\"\n```\n\n#### 驼峰化\n\n```js\nconst reg1 = /[-_\\s]+(\\w)/g;\nconst text = \"-moz-text----  _aligin\";\n//驼峰化\nconst s1 = text.replace(reg1, function (match, c) {\n  //console.log(c);\n  return c ? c.toUpperCase() : \"\";\n});\n\nconsole.log(s1);\n// MozTextAligin\n```\n\n#### 中划线化(反驼峰化)\n\n```js\nconst reg2 = /([A-Z])/g;\n//中划线化\nconst s2 = \"Hello WorldLick   \"\n  .replace(reg2, \"-$1\")\n  .replace(/[-_\\s]+(?=\\w)/g, \"-\")\n  .toLowerCase();\nconsole.log(s2);\n//-hello-world-lick\n```\n\n#### html 转义和反转义\n\n转义：\n\n```js\n// 将HTML特殊字符转换成等值的实体\nfunction escapeHTML(str) {\n  var escapeChars = {\n    \"¢\": \"cent\",\n    \"£\": \"pound\",\n    \"¥\": \"yen\",\n    \"€\": \"euro\",\n    \"©\": \"copy\",\n    \"®\": \"reg\",\n    \"<\": \"lt\",\n    \">\": \"gt\",\n    '\"': \"quot\",\n    \"&\": \"amp\",\n    \"'\": \"#39\",\n  };\n  return str.replace(\n    new RegExp(\"[\" + Object.keys(escapeChars).join(\"\") + \"]\", \"g\"),\n    function (match) {\n      return \"&\" + escapeChars[match] + \";\";\n    }\n  );\n}\nconsole.log(escapeHTML(\"<div>Blah blah blah</div>\"));\n// => \"&lt;div&gt;Blah blah blah&lt;/div&gt\";\n```\n\n反转义：\n\n```js\n// 实体字符转换为等值的HTML。\nfunction unescapeHTML(str) {\n  var htmlEntities = {\n    nbsp: \" \",\n    cent: \"¢\",\n    pound: \"£\",\n    yen: \"¥\",\n    euro: \"€\",\n    copy: \"©\",\n    reg: \"®\",\n    lt: \"<\",\n    gt: \">\",\n    quot: '\"',\n    amp: \"&\",\n    apos: \"'\",\n  };\n  return str.replace(/\\&([^;]+);/g, function (match, key) {\n    if (key in htmlEntities) {\n      return htmlEntities[key];\n    }\n    return match;\n  });\n}\nconsole.log(unescapeHTML(\"&lt;div&gt;Blah blah blah&lt;/div&gt;\"));\n// => \"<div>Blah blah blah</div>\"\n```\n\n#### 匹配成对标签\n\n要求匹配：\n\n```html\n<title>regular expression</title>\n<p>laoyao bye bye</p>\n```\n\n不匹配：\n\n```html\n<title>wrong!</p>\n```\n\n```js\nvar regex = /<([^>]+)>[\\d\\D]*<\\/\\1>/;\nvar string1 = \"<title>regular expression</title>\";\nvar string2 = \"<p>laoyao bye bye</p>\";\nvar string3 = \"<title>wrong!</p>\";\nconsole.log(regex.test(string1)); // true\nconsole.log(regex.test(string2)); // true\nconsole.log(regex.test(string3)); // false\n```\n\n## 正则表达式回溯法原理\n\n正则的匹配原理就涉及到回溯，这里我们来谈谈回溯。\n\n### 没有回溯的匹配\n\n其实一个正则表达式匹配过程有没有涉及到回溯是跟我们的写法和要匹配的字符串有关。\n比如以下正则：\n\n```js\n/ab{1,3}c/;\n```\n\n![image.png](https://topzhang.cn/usr/uploads/2022/03/4101041783.png)\n当目标字符串是`abbbc`时，就没有所谓的回溯，其匹配结果如下：\n![image.png](https://topzhang.cn/usr/uploads/2022/03/3262457941.png)\n可以看到正则每次尝试都能完美匹配。\n但是我们匹配字符串`abbc`就会出现回溯现象，其匹配结果如下：\n![image.png](https://topzhang.cn/usr/uploads/2022/03/1054837739.png)\n在第五步的时候`b`还有一个未匹配,所以就回去尝试用第三个`b`去匹配，但是遇到了`c`所以`b{1,3}`就认为匹配完成，，然后状态会回到第六步，当然和第四步一样，用剩下的`c`去匹配，最后匹配成功，这个正则就完成匹配了。\n当然图中第六步就是回溯。\n\n这里我们举个例子，以下正则：\n`/ab{1,3}bbc/`\n去匹配字符串`abbbc`,匹配过程是：\n![image.png](https://topzhang.cn/usr/uploads/2022/03/2055172755.png)\n\n其中第七步和第十步就是回溯，首先`b{1,3}`会尽可能的匹配，但是到之后发现剩下的字符不能匹配了才会做出“让步”,尝试匹配 2 个，但是发现匹配两个还是不满足，就只能匹配一个了，此时`b{1,3}`只匹配了一个\"b\"，这也是`b{1,3}`的最终匹配结果。\n\n再看一个清晰的正则回溯匹配：\n正则为：`/\".*\"/`,要求匹配字符串为`\"acd\"ef`,匹配结果如下：\n![image.png](https://topzhang.cn/usr/uploads/2022/03/3045318079.png)\n\n可以看到._首先会匹配完后面所有的字符，然后再慢慢回溯进行匹配。\n所以看得出来有回溯的匹配是会影响性能的。\n我们可以把上面的正则改为：`/\"[^\"]_\"/`。\n\n### 常见的回溯形式\n\n正则表达式匹配字符串的这种方式，有个学名，叫回溯法。回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。（copy 于百度百科）。\n本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。\n\n接下来介绍常见会产生回溯的地方\n\n#### 贪婪量词\n\n我觉得我没啥补充的了，所以直接抛出原文链接[JS 正则表达式完整教程](https://juejin.cn/post/6844903487155732494#heading-24)\n\n## 常用 API 补充\n\n用于正则操作的相关 API 共 6 个，字符串操作 4 个，正则有 2 个\n\n### test\n\n这个是正则的一个最常用的 API 了，用于检测正则表达式与指定的字符串是否匹配：\n\n```js\nconst str = \"table football\";\n\nconst regex = new RegExp(\"foo*\");\nconst globalRegex = new RegExp(\"foo*\", \"g\");\n\nconsole.log(regex.test(str));\n// expected output: true\n\nconsole.log(globalRegex.lastIndex);\n// expected output: 0\n\nconsole.log(globalRegex.test(str));\n// expected output: true\n\nconsole.log(globalRegex.lastIndex);\n// expected output: 9\n\nconsole.log(globalRegex.test(str));\n// expected output: false\n```\n\n匹配就返回`true`，否者返回`false`。\n如果正则表达式设置了全局标志，`test()`的执行会改变正则表达式`lastIndex`属性。连续的执行`test()`方法，后续的执行将会从`lastIndex`处开始匹配字符串，(`exec()` 同样改变正则本身的`lastIndex`属性值)。\n\n### match\n\n方法检索返回一个字符串匹配正则表达式的结果。\n\n```js\nconst paragraph = \"The quick brown fox jumps over the lazy dog. It barked.\";\nconst regex = /[A-Z]/g;\nconst found = paragraph.match(regex);\n\nconsole.log(found);\n//[ 'T', 'I' ]\n```\n\n注意：如果正则表达式不包含 `g` 标志，`str.match()` 将返回与 `RegExp.exec()`. 相同的结果。\n\n### exec\n\n`exec()` 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或`null`。\n\n在设置了 `global` 或 `sticky` 标志位的情况下（如 /foo/g or /foo/y），`JavaScript RegExp` 对象是有状态的。他们会将上次成功匹配后的位置记录在 `lastIndex` 属性中。使用此特性，`exec()` 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， `String.prototype.match()` 只会返回匹配到的结果。\n\n```js\nconst paragraph = \"The quick brown fox jumps over the lazy dog. It barked.\";\nconst regex = /[A-Z]/g;\nconst found = regex.exec(paragraph);\n\nconsole.log(found);\n```\n\n### search\n\n传入一个正则表达式对象，如果匹配成功，则 `search() `返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。\n\n```js\nvar str = \"hey JudE\";\nvar re = /[A-Z]/g;\nvar re2 = /[.]/g;\nconsole.log(str.search(re)); // returns 4, which is the index of the first capital letter \"J\"\nconsole.log(str.search(re2)); // returns -1 cannot find '.' dot punctuation\n```\n\n### replace\n\n这个函数很强大，详情见[mdn-replace](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace)\n\n### split\n\n可以使用正则来进行分组\n第一，它可以有第二个参数，表示结果数组的最大长度，第二，正则使用分组时，结果数组中是包含分隔符的：\n\n```js\nvar string = \"html,css,javascript\";\nconsole.log(string.split(/,/, 2));\n// =>[\"html\", \"css\"]\n```\n\n```js\nvar string = \"html,css,javascript\";\nconsole.log(string.split(/(,)/));\n// =>[\"html\", \",\", \"css\", \",\", \"javascript\"]\n```\n\n更详细的内容如下：[mdn--exec](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\n\n文章来源 [JS 正则表达式完整教程](https://juejin.cn/post/6844903487155732494)\n本人只做了一些额外的补充。\n\n\n",
      "type": 1,
      "id": 5
    }
  ],
  "categoryList": [
    {
      "id": 11,
      "name": "默认分类",
      "slug": "default11111",
      "description": "你不选我帮你选！"
    },
    {
      "id": 1,
      "name": "js",
      "slug": "js",
      "description": "前端语言"
    },
    {
      "id": 2,
      "name": "java",
      "slug": "java",
      "description": "服务器语言"
    },
    {
      "id": 3,
      "name": "go",
      "slug": "go",
      "description": "服务器语言"
    },
    {
      "name": "121",
      "slug": "1212112",
      "description": "122222",
      "id": 12
    },
    {
      "name": "21",
      "slug": "212",
      "description": "1212",
      "id": 13
    },
    {
      "name": "2323",
      "slug": "232",
      "description": "32",
      "id": 14
    },
    {
      "name": "1www",
      "slug": " www",
      "description": "哇哇哇哇",
      "id": 15
    }
  ]
}
